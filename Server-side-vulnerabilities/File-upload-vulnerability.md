# File Upload Vulnearbility

- File upload vulnearbility is when a server is allow user to upload file to the system without sufficiently validating things like, type, content, size etc.
- this can lead to potentially dangerous file uploads, that comporomize whole web server/network and cause many damage

## Impact of file upload vulnerability 
### Depands on
1. which aspect of file type the website fails to validate properly, whethere its be size,type, contents etc
2. what restriction are imposed on the file once it has been sucessfully uploaded.

## How file upload vulnerabiltiy arises ?
- eg. they have blacklist for dangerous file types, but fail to account for parsing discrepancies when checking the file extensions.
- other case: server attempt to check the file type by verifying properties that can be easily manipulated by attacker using proxy tools.

### How web server handle request for static files?
- server parse the file path in the request to identify file type, & determine whether to directly send to the client or parse and send the reesult
- eg. Image/non-executable file, & static html page, server send file's content to the client
- eg. executable file like Php, & server configured to execute this type of files, so server execute that file and send the result/output to the client.
- if file type is executable but server not configure to execute the file, then return the error to the client

`The Content-Type response header may provide clues as to what kind of file the server thinks it has served. If this header hasn't been explicitly set by the application code, it normally contains the result of the file extension/MIME type mapping.`

## Exploiting unrestricted file uploads to deploy a web shell

```php
<?php echo system($_GET['cmd']); ?>
```

## Exploiting Flawed validation of file uploads
### Flawed file type validation
- when sending text file `content-type: application/x-www-url-encoded` used for sending text data or small data
- when sending large file liek PDf and binary data we used `content-type: multipart/form-data`

eg. form request 
```js
POST /images HTTP/1.1  
Host: normal-website.com  
Content-Length: 12345  
Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456  
  
---------------------------012345678901234567890123456  
Content-Disposition: form-data; name="image"; filename="example.jpg"  
Content-Type: image/jpeg  
  
[...binary content of example.jpg...]  
  
---------------------------012345678901234567890123456  
Content-Disposition: form-data; name="description"  
  
This is an interesting description of my image.  
  
---------------------------012345678901234567890123456  
Content-Disposition: form-data; name="username"  
  
wiener  
---------------------------012345678901234567890123456--
```

- server is checking for mime type for controlled file upload like png/jpg by checking Contnt-type of each content-Disposition 
- Bypass: we change that content-type that server want & by this we bypasing restriciton & upload shell/scripts

### preventing File execution in user-accessible directories
- some time server is configured to execute the scripts in perticular directory, and block the excution of scripts in the directory where the uesr have access to upload files, and if we upload malicious file successfull, when we visit them its return content of the file instead of executing that script.
- to bypass this and got code execution we need to store the file in other directory which server doesnt store uploaded content, so there we got execute our file
`Web servers often use the filename field in multipart/form-data requests to determine the name and location where the file should be saved.

- file upload via path traversal to execute code.
- if didn't got success at 1st time try using some URl encoding to to bypass the striping of `/` char
- You should also note that even though you may send all of your requests to the same domain name, this often points to a reverse proxy server of some kind, such as a load balancer. Your requests will often be handled by additional servers behind the scenes, which may also be configured differently.

## Insufficient Blacklisting of Dangerous file types
- one way to prevent for malicious file upload is blacklist the dangerous file types in uploading feature
- eg. php, this bypass by alternative `php5,shtml,etc`

### Overriding the server configuration
- many server allows developers to create special configuratino files within individual directories inorder to override or add more global settings, 
- eg. apache have `.htaccess` file 
- IIS have web.config file

#### Steps
we need to override the configuration or add new configuration fiel like .htaccess in apache 
- upload .htaccess with contetn-type: text/plain
-  add data to .htaccess file ``AddType application/x-httpd-php .any`` this will add configuration that, `.any` extension file will be executable MIME type `application/x-httpd-php` as server use `mod_php` module, it know how to handle it
-  now upload file php code file with `.any` extension and this will execute in the server & we got RCE

### Obfuscating File Extensions
- most exhaustive blacklist can be bypassed using classing obfuscation techniques
- like Php, pHp, PhP etc
- provide multiple extension file.php,jpg
- addinng Trailing componet liek `dots, forward-slash,backword-slash,` 
- also Url encode it `file%2Ephp` is file.php
- add `;` or `%00` null byte to extension, `file.asp%00.jpg` 
- Try using multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization. Sequences like `xC0 x2E`, `xC4 xAE` or `xC0 xAE` may be translated to `x2E` if the filename parsed as a UTF-8 string, but then converted to ASCII characters before being used in a path.
- Other defenses involve stripping or replacing dangerous extensions to prevent the file from being executed. If this transformation isn't applied recursively, you can position the prohibited string in such a way that removing it still leaves behind a valid file extension. For example, consider what happens if you strip `.php` from the following filename:`exploit.p.phphp`

### Flawed Validaiton of the File's contents
- instead of relaying on the `content Type:` specified in the request, the more secure server try to verify that  the contents of the file actually match what is expected
- for image, it can be based on dimensions, and php scripts does not have dimensions, and rejected 
- the file also contain specific sequence of bytes called magic number which used to identify which file type is there eg. jpeg always begin with `FF D8 FF`
- This can be bypass using Tool Like EXIFTOOL, used to create Polyglot JPEG file containing Malicious Code with its metadata.
```bash
exiftool -Comment="<?php echo 'START '.file_get_contents('/home/carlos/secret').' END'; ?>" index.jpg -o polyglot.php
```

### Race Conditions URL-based file Uploads
- Race condition can occure in functions that allow us to upload file by Providing URL, This case server has to fetch the file over the internet and create a local copy before it can perform any validation 
- As the file is loaded using HTTP, developers are unable to use their framework's built-in mechanisms for securely validating files. Instead, they may manually create their own processes for temporarily storing and validating the file, which may not be quite as secure.
- To make attacks like this easier, you can try to extend the amount of time taken to process the file, thereby lengthening the window for brute-forcing the directory name. One way of doing this is by uploading a larger file. If it is processed in chunks, you can potentially take advantage of this by creating a malicious file with the payload at the start, followed by a large number of arbitrary padding bytes

## Exploiting File upload vulnerability without RCE
### Uploading Malicious Client Side Scripts
- we can upload HTML/SVG files and create `Stored XSS` on server

### Exploiting Vulnerability in the parsing of uploaded files
- if server parse xml-based files eg. Microsoft office, .doc,.xls we have `XXE Injection`

### Uploading Files using PUT
- It's worth noting that some web servers may be configured to support `PUT` requests. If appropriate defenses aren't in place, this can provide an alternative means of uploading malicious files, even when an upload function isn't available via the web interface.

```js
PUT /images/exploit.php HTTP/1.1  
Host: vulnerable-website.com  
Content-Type: application/x-httpd-php  
Content-Length: 49  
  
<?php echo system($_GET['cmd']); ?>
```

- we can send options methods to all urls and see if PUT methods is allowed or not


## Prevention against File upload vulnearbilities
- Check the file extension against a whitelist of permitted extensions rather than a blacklist of prohibited ones. It's much easier to guess which extensions you might want to allow than it is to guess which ones an attacker might try to upload.
- Make sure the filename doesn't contain any substrings that may be interpreted as a directory or a traversal sequence (`../`).
-  Rename uploaded files to avoid collisions that may cause existing files to be overwritten.
-  Do not upload files to the server's permanent filesystem until they have been fully validated
-  As much as possible, use an established framework for preprocessing file uploads rather than attempting to write your own validation mechanisms