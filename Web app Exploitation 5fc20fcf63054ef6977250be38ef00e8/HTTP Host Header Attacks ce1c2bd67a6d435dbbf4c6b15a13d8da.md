# HTTP Host Header Attacks

![http-host-header-attack.png](HTTP%20Host%20Header%20Attacks%20ce1c2bd67a6d435dbbf4c6b15a13d8da/http-host-header-attack.png)

## What is HTTP Host header

- HTTP host header is the mandatory request header as of `HTTP/1.1` it specifies the domain name that the client wants to access.
`example:` `https://any-web.com/dict` if you visit this,the browser will compose a request containing host header as follow

```
GET /dict HTTP/1.1
Host: any-web.com

```

## Purpose of Host header

- it is used to identify which back-end component the client want to communicate with.
- if the request didn't contain `host header` or `host host header is malformed` in some way, it lead to issue when routing incoming requests to the application.

## Virtual Hosting

- one scenario is when a single web-server hosts multiple websites or applications.
- this could be multiple website with a single owner, but it is also possible for website with different owners to be hosted on a single, shared platform.
- website hosted on a single server known as `virtual host`

## Routing Traffic via Intermediary

- Another common scenario is when websites are hosted on distinct back-end servers, but all traffic between the client and servers is routed through an intermediary system.
- This could be `simple load balancer` or `reverse proxy server`of some kind.
- in This case even if the website is hosted on separate back-end servers, all of their domain-name resolve to a single `IP address`.

## How HTTP host header solve this problem

`example:` we want to send mail to certain person, he lived in apartment, so all of his neighbor have same address, but different house number.

- here the `Host header` works as `House number for the website or server`
- when browser sends HTTP request, the Target URL resolves to IP address of particular server, when server receives the request, if refers to `host header` to determine the intended back-end and forward the request.

## What is HTTP Host Header Attack

- it is exploitation of vulnerable website/application that handle value of `host header` in the unsafe way
- if server implicitly trust `host header` and fails to validate or escape it properly, an attacker may be able to use this input to `inject harmfull payload`
- since the `host header` is user controllable, this can lead to many vulnerabilities if this is not properly `escaped or validate`
- resulting Vulnerabilities are
    - `web cache poisoning`
    - `Buisness-logic flaws`
    - `Routing Based SSRF`
    - `Classic Server side Vulnerabilities like SQLI etc`

## How Host Header vulnerabilities arise.

- this vulnerability arise due to false assumption that the `header` is not `user controlable`.
- this creates implicit trust in the host header and result in inadequate validation or escaping of its value.
- many of these vulnerability is not arise due to insecure coding but due to insecure configuration of one or more components in the related infrastructure.
- this configuration issue occur due to website/application integrate third-party technologies into their architecture without necessarily understanding the configuration options and their security implication.

# Exploiting Host Header Vulnerabilities

## How to test for vulnerabilities using Host header

- using proxy tools like burpsuite and intercepting request and `modify the host header` and verify that we still reach the target application with our header, if yes than we use this header to probe the application and observe effect on the response

## Supply an arbitrary Host Header

- when testing for host header injection, then 1 st step is to see what happened when we apply any `arbitrary unrecognized domain name` in `host header`.
- sometimes we will still be able to access the target website even when ww supply unexpected `host header` this might be exploitable.
- some times tempering with `host header` gives us unable to reach the target application and the front-end server or load-balancer doesn't know where to forward the request and resulting `Invalid Host header` error.

## Check For Flawed Validation

- sometimes instead of getting `Invalid Host header` , we find that our request is `Blocked` as a result of some kind of security.
`example:` website/application checks that `host header` matched `SNI from the TLS handshake`, but this not mean they are immune to `Host header injection`
- understand how website/application parse the `host header`, this can reveal loopholes that used to bypass validation.
`example:` some parsing algo, omit the port number from `Host header`, meaning only domain name is validated, we supply `non-numeric port`, can leave the domain name untouched to ensure that you reach the target application while `injection our payload`

```
GET /example HTTP/1.1
Host: vuln-web.com:our-payload

```

- other application apply matching logic to allow for arbitrary subdomains, in this case we bypass validation by registering arbitrary domain name that ends with same sequence of character the whitlisted

```
GET /example HTTP/1.1
Host: new-byed-domainvuln-web.com

```

alternative take advantage of less-secure subdomain that have compromised

```
GET /example HTTP/1.1
Host: compromised-subdomain.vuln-web.com

```

# Send Ambiguous Request

- by identifying and exploiting discrepancies in how they retrieve the `host header` , we may request ambiguous request that appears to have a different host depending on which system is looking

## Inject Duplicate Host Header

- sometimes developer allow duplicate host header by mistackenly.
- the different system, technology handle it differently but commonly one of two headers to be given precedence over the other one,by overriding its value. this might be exploitable.

```
GET /example HTTP/1.1
Host: vuln-web.com
Host: attacker.domain

```

- here front-end gives precedence to the first instance of `header` but the back-end prefer the `final` instance of header.
- in this scenario we use 1 st header to route our request to application
- and 2 nd request we sent our payload there

## supply absolute URL

- although request are typically a relative path on the requested domain, many servers are also configured to understand requests for absolute `URL`s
- officially request line given precedence when routing the request, but in practice this isn't always case, we exploit this discrepancies in the same way as duplicate HOST header

```
GET <https://vuln-web.com/> HTTP/1.1
Host: our-payload

```

sometimes we need to switch protocol http to https or alternate due to servers behavior

## Add line wrapping

- we uncover quirk behavior of server by `identing` HTTP headers with `space charecter`, some server interpret indented header as wrapped line , other may ignore the indented header altogether
- due to highly inconsistent handling of the case, there will often be discrepancies between different systems that process your request.

```
GET /example HTTP/1.1
 Host: our payload
Host: vuln-web.com

```

- website/application may block the request with multiple headers, we bypass this by `indenting one of the header` like this.

## inject Host override header

- Even if we can't able to override the host header using `ambigious request` there are other possibilities for overriding its value.
- this is via injecting our payload via one of several other `HTTP headers` that are designed to serve just this purpose
- `X-Forwarded-Host:` header is present, than many frameworks will refer to this instead other Host header.
- so sometimes we use `X-Forwarded-Host:` to inject our malicious input while circumventing any validation on the `host header`

```
GET /example HTTP/1.1
Host: vuln-web.com
X-Forwarded-Host: our-payload

```

there is other headers that also serves the similar purpose

```
X-Host:
X-Forwarded-Server:
X-HTTP-Host-Override:
Forwarded:

```

we use `param miner` to guess or find headers that is supported by the application.

# How to exploit HTTP host header

- once we have identified that we pass arbitrary hostnames to the target application, we start looking for exploitation.

## Password reset Poisoning

- it is a technique whereby an attacker manipulate a vulnerable website/application into `generating password reset link pointing to domain under their control`

### Constructing Password reset Poisoning

- obtain victim's email
- send request to password reset using victim's email and intercept the request and modify the `host header to attacker control domain`
- victim receives ordinary reset link but the domain with the attacker's control, so when victim click the link, request go to the attacker's domain with `reset token` and attacker can use this token to reset the password of the victim.

`NOTE`: for the password poisoning victim should click on the link.

[labs portswigger](https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning)

## Web cache Poisoning via Host header

- when probing for potential `HOst header attacks`, we come across vulnerable behavior that isn't directly exploitable
`Example:` we find that Host header is reflected in the response markup without `HTML encoding` or even directly in `scripts imports`, since `XSS` can exploitable when they're caused by `host header`, since there is no way to force the victim to issue incorrect host in a useful manner.
- but if target Uses `web cache` it may possible to turn this useless, reflected vulnerability into dangerous, stored one by `poisoning cache` or serve `poisoned response` to other users.

## Exploiting Classic Server-side vulnerability using host header injection

- HTTP host header is a potential vector for exploiting classic server-side vulnerabilities
- we try the usual `SQL injection` probing techniques via Host header, if the value is passed into a `sql statement` this could be exploitable.

## Accessing Restricted Functionality

- since it is common for website to restrict some functionality to internal users only.
- some's website/applications `access control` feature allow us to bypass these restriction by making modification to the `HOST headerHost header auth bypass`

## Accessing Internal website with Virtual host Brute-forcing

- some companies sometimes make the mistake of hosting publicly accessible website/application and private , internal sites on the `same server`
- servers typically have both `public` and `private` IP address , as internal-hostname may resolve the private IP address.
- this doesn't detected by looking At DNS records

```
www.example.com: 12.34.56.78
internet.example.com: 10.10.0.12

```

- since internal site don't have DNS records, typically attacker access the virtual host on any server , guess the hostname, if they discovered domain name through `information disclosure`, also use `burp intruder` to bruteforce the virtual-hosts using wordlists of candidate subdomains

## Routing Based SSRF

- some times possible to use host header to launch high-impact, routing-based SSRF attacks, this also known as `Host header SSRF attacks`
- classic `SSRF`are based on `XXE` or other `business logic` that sends request to URL derived from user controllable input.
- Routing Based `SSRF` is relies on the exploiting the intermediary components that are prevent in many cloud-based architecture. this include inhouse `load balancer` and `reverse proxy`
- these component deployed for different purpose, they receive request `from the public` and forward it to `back-end`, if they are insecurely configured to forward request based on `unvalidated host header`, they can be manipulated into `misrouting requests` to arbitrary system of the attacker's choice.
- these system is fantastic target, because they sit in the `priviliged position`, that allows them to receive request from `public` and also have access to `internal network`, this make `host header` a powerful vector for `SSRF attacks`by simply transforming `load balancer` to gateway to the entire `internal network`
- we can use `burp collaberator` to for finding attack surface, if we got DNS lookup from the internal machine.
- after confirming that we can successfully manipulate an intermediary system to route your request to an `arbitrary public server`, next is to see if we exploit this behavior to access `internal-only systems`.
- TO do this we need to identify `private IP addresss` that are in use on the target's internal network.
- in addition to any `ip Address` leaked by the `application`, we scan hostname belongs to the company to see if any `resolve to private ip Address`.
- we bruteforce standerd `private IP range` eg. `192.168.0.0/16`, `10.0.0.0/16` etc
[lab protswigger](https://portswigger.net/web-security/host-header/exploiting/lab-host-header-ssrf-via-flawed-request-parsing)`SSRF via Flawed Request parsing`
- this allow us to request like this

```
GET <https://your-lab-id.web-security-academy.net/>
Host: your-collaborator-id.burpcollaborator.net

```

so here we inject arbitrary host that is lookup by the `load balancer or reverse proxy` and we got in to internal network

## SSRF via Malformed Request Line

- Custom Proxies sometimes fail to validate the request line properly, which can allow us to supply `unusual, malformed input` with unfortunate results.
- `example:` reverse proxy might take the path from the request line, prefix it with `http://backend-server` and route the request to that upstream `URL` this works if the file path starts with `/` character but what if starts with `@` character instead.

```
GET @private-internet/example HTTP/1.1

```

resulting Upstream URL is `https://backend-server@private-internet/example` which most `HTTP` libraries interpret as a request access `private-internet` with the username `backend-server`

# Prevention

- validate the host header
- protect absolute URLs
- Don't support Host Override headers
- Whitelist Permitted Domains