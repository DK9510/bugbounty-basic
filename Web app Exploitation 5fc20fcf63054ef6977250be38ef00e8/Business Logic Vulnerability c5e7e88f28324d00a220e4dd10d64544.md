# Business Logic Vulnerability

## [what are Business Logic vulnerability](https://portswigger.net/web-security/logic-flaws)

- Business logic vulnerabilities are flows that arise in the design and implementation of an application that allow an attacker to elicit Unintended Behavior. This potentially enables attackers to manipulate legitimate functionality to achieve a malicious goal.
- Logic flaws are often invisible to people who aren't explicitly looking for them as they typically won't be exposed by normal use of the application. However, an attacker may be able to exploit behavioral quirks by interacting with the application in ways that developers never intended.
- Flaws in the logic can allow attackers to circumvent these rules. For example, they might be able to complete a transaction without going through the intended purchase workflow.
- the business logic vulnerability is unique and diverse depending on the target application, so it needed manual testing because it is very difficult to detect using automated scanner.

## how it arise

- Business logic vulnerabilities often arise because the design and development teams make flawed assumptions about how users will interact with the application.
- Logic flaws are particularly common in overly complicated systems that even the development team themselves do not fully understand.
- Developers working on large code bases may not have an intimate understanding of how all areas of the application work.

## Impact OF logic vulnerabilities

- the impact of business logic vulnerabilities is depend on the application and which logic or area of the application are broken.
- it depend on the functionalities.
- eg. the flow in authentication then it is high severity due to it risks overall security.

# Examples

## Excessive Trust in Client-side Controls

- A fundamental flawed assumption is that users will only interact with the application via a provided web interface.
- developer think the client side filters and validation prevent the user from inserting malicious code.
- but this client side validation simply bypass using 3rd party proxy like burp proxy.
- just simple like parameter tempering or
- 2FA Broken logic that is part of authentication [[2-multifactor-authentication]]

## Filing to Handle Unconventional input

- one aim of the application logic is to restrict user input to values that adhere to the business rules. For example, the application may be designed to accept arbitrary values of a certain data type, but the logic determines whether or not this value is acceptable from the perspective of the business.
- Let's take the simple example of an online shop. When ordering products, users typically specify the quantity that they want to order. Although any integer is theoretically a valid input, the business logic might prevent users from ordering more units than are currently in stock.
- For example, a numeric data type might accept negative values. Depending on the related functionality, it may not make sense for the business logic to allow this. However, if the application doesn't perform adequate server-side validation and reject this input, an attacker may be able to pass in a negative value and induce unwanted behavior
- By observing the application's response, you should try and answer the following questions
    - are there any limits are imposed on the data.
    - what happens when you reach those limits.
    - is any transformation or normalization being performed on your input.
- this may expose weak input validation that allows you to manipulate the application in unusual ways
- keep in mind that if we find one form on the target that fails to safely handle unconventional input, it is likely that other form may have same issue.

[broken-logic-at-account-registration](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-inconsistent-handling-of-exceptional-input)

## Making flawed assumptions about user behavior

some times developer assume about user behavior that user is trusted and didn't supply any dangerous input.

- some time we know that only some specific domain name have access to internal service or admin panel
- so if there is any update email option we change it and if doesn't verify the email by sending OTP.
- we simply change the email to internal employees domain and we may get admin access.
- [broken logic in email verification](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-inconsistent-security-controls)

## Users won't Always supply mandatory input

- One misconception is that users will always supply values for mandatory input fields. Browsers may prevent ordinary users from submitting a form without a required input, but as we know, attackers can tamper with parameters in transit. This even extends to removing parameters entirely.
    - only remove one parameter at a time to ensure all relevant code paths are reached.
    - try deleting name of the parameter as well as the value.
    - Follow mult-stage process through to completion. some time tampering with parameter in one step will have an affect on another step further along in the workflow.

## weak Isolation on Dual-use endpoint

- Study the `POST /my-account/change-password` request in Burp Repeater.
- Notice that if you remove the `current-password` parameter entirely, you are able to successfully change your password without providing your current one.
- Observe that the user whose password is changed is determined by the `username` parameter. Set `username=administrator` and send the request again.
- Log out and notice that you can now successfully log in as the `administrator` using the password you just set.

### password-reset-broken-logic

[[3-Vuln-in-other-auth-mechanism]]

## user won't always follow the intended sequence

- Many transactions rely on predefined workflows consisting of a sequence of steps. The web interface will typically guide users through this process, taking them to the next step of the workflow each time they complete the current one. However, attackers won't necessarily adhere to this intended sequence.
- For example, many websites that implement two-factor authentication (2FA) require users to log in on one page before entering a verification code on a separate page. Assuming that users will always follow this process through to completion and, as a result, not verifying that they do, may allow attackers to bypass the 2FA step entirely.
- To Identify these kind of flows, we use forced browsing to submit request in unintended sequence.
- **example:** we skip certain steps, access single step more than once.return to earlier state etc
- analyze the request sequence and see if you can drop some and directly go to another request end point that affect overall application.
- [example](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-flawed-state-machine)

## Domain-specific flaws

- In many cases, you will encounter logic flaws that are specific to the business domain or the purpose of the site.
- For example, consider an online shop that offers a 10% discount on orders over $1000. This could be vulnerable to abuse if the business logic fails to check whether the order was changed after the discount is applied.
- You should pay particular attention to any situation where prices or other sensitive values are adjusted based on criteria determined by user actions.
- Try to understand what algorithms the application uses to make these adjustments and at what point these adjustments are made.
- some times application doesn't verify if discount coupon repeated after another different coupon so attacker take advantage of it applying 2 coupon 1 after another so he got unlimited amount of discount.
- [example](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-infinite-money)

## infinite-money logic-flow And create macro for exploitation

[example](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-infinite-money)

## providing an encryption Oracle

- Dangerous scenarios can occur when user-controllable input is encrypted and the resulting ciphertext is then made available to the user in some way. This kind of input is sometimes known as an "encryption oracle". An attacker can use this input to encrypt arbitrary data using the correct algorithm and asymmetric key.
- This becomes dangerous when there are other user-controllable inputs in the application that expect data encrypted with the same algorithm. In this case, an attacker could potentially use the encryption oracle to generate valid,encrypted input and then pass it into other sensitive functions.
- [example](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-authentication-bypass-via-encryption-oracle).

# Prevent Business Logic vulnerabilities

- Make sure developers and testers understand the domain that the application serves.
- Avoid making implicit assumptions about user behavior or the behavior of other parts of the application.
- identify the assumption you have made about server-side state and implement the necessary logic to verify these assumption are met.
- Maintain clear design documents and data flows for all transactions and workflows, noting any assumptions that are made at each stage.
- Note any references to other code that uses each component. Think about any side-effects of these dependencies if a malicious party were to manipulate them in an unusual way.